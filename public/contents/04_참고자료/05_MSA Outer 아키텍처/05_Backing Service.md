## Backing Services

이벤트드리븐 기반의 마이크로서비스에서 Backing Service 는 메세지의 송신자와 수신자가 직접 통신하지 않고 메시지큐를 활용한 비동기 통신 프로토콜을 사용합니다. 

마이크로서비스간의 통신이 필요한 비즈니스의 경우 실시간으로 진행되도록 구성한 마이크로서비스들은 장애 발생, 트래픽 증가 또는 소스 반영 등의 이벤트가 발생할 경우 마이크로서비스 오케스트레이션을 진행하며 또다른 마이크로서비스를 신규 생성, 재생성 등의 작업을 수행하게 됩니다.

그래서 강결합 구조의 실시간 트랜잭션 기반의 서비스를 제공하면 트랜잭션이 끊어지기 때문에 서비스 요청을 보존할 수 없고 에러가 발생하게 됩니다.

그래서 서비스 영속성을 지속하기 위하여 메시지 큐를 활용하고 리소스와의 결합을 느슨하게 하여 언제든지 붙이거나 떼어 낼 수 있도록 Backing Service를 구성하여야 합니다. 

또한 마이크로서비스들간의 비동기 처리가 필요하거나 타 마이크로서비스의 데이터 접근이 빈번하여 API 호출 과다 발생 시에도 데이터 공유 혹은 데이터 대상 리포팅을 준실시간 동기화를 수행하도록 합니다.

<br/>

### **Backing Service 패턴**

#### **\[point-to-point 아키텍처 패턴\]**

> ![](/img/03_Bizdevops/07/05/image112.png)

Point-to-point 패턴에서는 하나의 마이크로서비스가 다른 마이크로서비스의 호출이 필요한 경우 동기식 방식으로 직접 호출하지 않고 메시지큐로 메시지를 보내는 방식으로 통신을 합니다. 

메시지 큐로 보내진 메시지는 대기열에 배치되고 메시지큐에서 마이크로서비스로 직접 메시지를 보내거나 수신하는 마이크로서비스가 polling 하는 패턴입니다.
Point-to-point 패턴에서 메시지 큐에서는 수신하는 마이크로서비스에 대한 정보를 알고 있어야 메시지를 보낼 수 있습니다.

예를 들어, 메시지큐에 다수의 마이크로 서비스가 메시지를 보냈다 하더라도 각각의 메시지들은 반드시 하나의 마이크로서비스에 맵핑되게 됩니다. 

간단한 비동기성 메시지 처리에 적합하며 송신 마이크로서비스와 수신 마이크로서비스가 분리되어 서로에게 영향을 끼치지 않는 장점이 있습니다. 그러나 메시지큐의 작업이 많아 부하가 걸릴 경우 마찬가지로 장애를 일으키는 단점이 있습니다.

#### **\[경쟁 소비자 아키텍처 패턴\]**

> ![](/img/03_Bizdevops/07/05/image113.png)
 
경쟁 소비자 패턴의 경우 다수의 메시지를 분산처리하기 위한 환경에 적합합니다. 수신 마이크로서비스 ( 이하 소비자 )가 여러 메시지를 동시에 처리할 수 있도록 다수의 경쟁 소비자를 단일 채널에 생성합니다. 

송신 마이크로서비스 ( 이하 송신자 )가 메시지를 메시지큐로 전달하게 되면 소비자들 중에서 하나의 수신자가 메시지를 받을 수 있습니다.
 
 Point-to-point 방식에서는 사용량이 갑작스럽게 증가하는 경우 서비스 장애나 많은 수의 메시지들로 인하여 오버로드가 발생할 수 있습니다. 
그래서 경쟁 소비자 패턴을 이용하여 시스템은 소비자 서비스의 여러 인스턴스를 실행하여 부하를 분산 시킨다. 

경쟁 소비자 패턴은 작업이 독립적이고 동시에 실행 가능할 경우, 작업의 양이 매우 가변적이어서 확장성이 필요한 경우, 고가용성을 제공하며 작업 처리 실패 시 복원되어야 할 경우 유용합니다. 

그러나 워크로드를 개별 작업으로 분리가 어렵고 종속성이 큰 경우, 동기적으로 작업을 수행하며 작업 프로세스에서 하나의 작업이 완료될때까지 기다려야 할 경우 특정 순서대로 작업을 수행할 경우는 부적합하며 실제 내부는 point-to-point 방식으로 동작하며 생산자와 소비자의 coupling 이슈는 해결되지 않습니다.
<br/>

#### **\[Pub/ Sub 아키텍처 패턴\]**

**1.  Pub/Sub 아키텍처**

> ![](/img/03_Bizdevops/07/05/image114.png)
 
Pub/Sub ( publish / subscription ) 패턴에서는 하나의 마이크로서비스가 교환기를 통하여 다수의 마이크로 서비스에게 메시지를 전달하는 패턴으로 한꺼번에 많은 소비자에게 메시지를 전달하는 구조에 적합합니다.
 
Pub/sub 패턴에서는 메시지를 전송하는 게시자(publisher)와 해당 메시지를 수신하는 구독자(subscription), 게시자로부터 메시지를 전달받아 메시지큐로 전송하는 교환기(exchange)로 나누게 됩니다. 

게시자는 전달하고자 하는 메시지를 교환기로 보내고 교환기는 다시 메시지 큐로 보내어 게시를 하게 되고 수신자 중에서 구독을 신청한 하나의 수신자를 지정하여 메시지를 보내거나 polling을 통하여 마이크로서비스가 메시지 큐에 접근하여 메시지를 가져간다.

Pub/sub 패턴에서는 메시지큐에서 소비자의 정보에 대해서 알고 있으므로, 소비자(구독자)로부터 공급자(게시자)를 분리할 수 있고 그래서 서로에 대한 정보를 알 필요가 없습니다.
 
그래서 병렬 작업, 메시지 캐싱, 트리 기반 또는 네트워크 기반의 라우팅을 통하여 기존의 클라이언트-서버 환경보다 뛰어난 확장성을 제공합니다. 
그러나 서비스의 호출이 많은 서비스의 경우 마찬가지로 높은 부하로 인하여 확장성은 감소합니다.
<br/>

**2.  라우팅 추가 pub/sub 아키텍처**

> ![](/img/03_Bizdevops/07/05/image115.png)
 
 기본적인 pub/sub 구조에서 메시지를 브로드캐스트 하였다면 교환기에 라우팅 기능을 추가하여 필터를 통하여 원하는 메시지를 원하는 역할의 메시지큐로 보내어 이를 처리하도록 합니다. 
 
 예를 들어 로그시스템의 경우 모든 로그를 수신하여 디스크에 저장할 경우 많은 유지 비용이 발생하게 됩니다. 필터를 통하여 교환기에서 error 담당 메시지큐로 error 메시지만 보내고 이를 디스크에 저장할 경우 error 메시지를 저장하는 유지비용만 발생하게 됩니다. 또한 메시지를 전용으로 처리하기 때문에 다수의 마이크로서비스로 부하를 분산하였던 방식에서 메시지큐까지도 부하를 분산하여 처리가 가능합니다.
<br/>

**3.  토픽 아키텍처**

> ![](/img/03_Bizdevops/07/05/image116.png)
 
 토픽 아키텍처의 경우 Pub/sub 구조에 교환기에서 direct로 메시지를 송신하지 않고 토픽을 게시하는 방식으로 이전에 소개한 아키텍처들은 direct로 메시지큐와 통신을 하며 하나의 메시지가 한 명의 소비자에 의해 수신되었다면 토픽의 경우는 메시지를 게시하면 관심 있는 모든 구독자가 메시지 사본을 받게 됩니다. 
 
 Point-to-point 방식의 Message queue와 비교하여 가용성과 확장성이 좋으며 point-to-multipoint 방식으로 구성됩니다. 또한 메시지큐도 게시자와 수신자의 정보를 알고 있을 필요가 없으며 메시지가 수신자에게 도착하면 게시자에게 알림이 전송됩니다. 메시지는 토픽에서 직접 수신되지 않으며 구독에서 수신합니다. 구독은 필터를 통하여 전달받는 메시지를 제한할 수 있습니다. 이 때 메시지의 사본을 구독하는 마이크로서비스가 없을 수도 있으며 메시지는 구독으로 식별된 메시지 큐에서 대기 (메시지 대기열)하는 위험이 있습니다.
<br/>

**4.  RPC 아키텍처**

> ![](/img/03_Bizdevops/07/05/image117.png)
 
 RPC( Remote Procedure Call ) 아키텍처 패턴은 메시지큐에서 양방향 통신을 가능하도록 하는 아키텍처 패턴입니다. 
 
 원격자의 함수를 실행시키고 결과를 회신받아야하는 아키텍처에서 구성하게 되며 어느 요청에 어느 큐가 응답해야하는지 명백하지 않기 때문에 고유의 ID를 부여하여 이를 해결하게 됩니다. 
 공급자와 소비자가 모두 소스를 수행하게 되며 공급자가 응답 정보를 담은 메시지를 먼저 게시하고 소비자는 소스를 통하여 다시 reply를 회신하는 패턴입니다.

<br/>

### **Backing Service구성 시 고려사항**

#### **\[데이터 영속성\]**

기존의 DBMS를 활용한 ACID 트랜잭션에 따른 데이터 무결성을 달성할 수 없으나 메시지큐를 사용하여 데이터의 최종적인 일관성 유지가 가능합니다. 

메시지큐에서는 디스크나 네트워크 메시지 복제 본, DBMS등에 저장하여 메시지의 영속성을 보장합니다. 또한 게시자로부터 메시지 전송이 완료되면 노드나 시스템의 충돌이 발생하여도 대기열에 포함되고 결국 Delivery를 함으로써 데이터의 영속성을 보장하게 됩니다. 

또한 메시지를 보내고 처리되었음을 보장해 주는 방법으로 message를 처리하는 마이크로서비스에서 confirm 메시지를 보냄으로써 생산자에게 메시지가 처리되었음을 완료해줌으로써 영속성을 보장합니다. 

하지만 rollaback의 경우는, 메시지 큐는 메시지를 재전달을 수행하는 방법과 에러를 발생시키는 방법이 있습니다. 반드시 rollback을 수행하여야 한다면 모놀리식 아키텍처에서는 하나의 transaction에 대해서 처리를 하였다면 마이크로서비스에서는 서비스마다 rollback발생 시 처리하는 로직을 개발하여야 합니다.

#### **\[내구성\]**

내구성을 확보하기 위하여 메시지를 메모리, 디스크, DBMS 중에 어느 곳에 보관할지 선정이 필요합니다. 

메시지를 디스크에 저장할 경우 메시지의 영속성이 보장되며 기존 메시징 시스템에서는 처리되지 않고 남아있는 메시지의 수가 많을수록 시스템의 성능이 크게 감소 되었으나 디스크에 저장할 경우 남아 있는 메시지가 많아도 성능이 크게 감소하지 않습니다. 
또한 실시간 처리, 주기적인 batch 작업에 사용할 데이터성(性) 메시지도 보관이 가능하며, Broker에게 한꺼번에 전달할 수 있어 TCP/IP 라운드트립 횟수를 줄일 수 있습니다. 그러나 메모리 처리 방식에 비해서는 처리 속도는 감소합니다.

- 데이터베이스에 저장할 경우 디스크에서 읽어 들이는 방식보다 메모리에 데이터베이스 복제본을 두고 메시지를 전송하기 때문에 성능이 향상되며 메시지의 내용과 상태의 확인이 용이합니다. 그러나 데이터베이스 유지비용과 스토리지 비용이 이중으로 발생하며 데이터의 삭제 주기를 설정하지 않으면 오히려 성능이 감소하며 유지비용이 증가합니다.

- 메모리에서 메시지를 처리할 경우 메모리는 휘발성이므로 시스템이 다운되거나 변경이 발생할 경우 캐시되어 있던 모든 메시지가 삭제됩니다.

- 그래서 내구성을 확보하기 위하여 디스크, DB, 메모리 등을 혼합하여 내구성을 확보하게 됩니다. Lazy Queue는 전달되는 모든 메시지를 파일 시스템으로 직접 보내고 소비자가 큐에 도착할 때 RAM에 메시지를 로드하면서 작동하며  디스크 읽기를 최적화하기 위해 메시지가 일괄 적으로 로드됩니다. 또 다른 하이브리드 방식으로는 메시지 큐에서 메시지가 지속되어야 하는지 여부를 판별하여 지속 될 경우 RAM에 있는 메시지를 디스크로 복제합니다. 램에 있는 메시지는 계속하여 캐시되어 있으며 메시지가 전달될 때 빠르게 전달하게 되면서 성능을 확보하게 됩니다.

- 이 밖에도 CSP에서는 메시지큐 생성 시 사용자는 메시지를 어느 곳에 저장해야 할 지 고민할 필요가 없습니다. CSP내부에서 메시지 큐들은 여러 개로 복제되어 메시지를 보관하기 때문입니다. 
제공하는 방식은 표준 대기열 방식에서는 최소 1회의 메시지 delivery를 지원하며 FIFO 대기열은 1회의 메시지 처리를 보장합니다. 만약에 메시지의 저장이 필요하다면 기존의 디스크, DB도 다른 서비스를 연계하여 사용할 수 있습니다.

#### **\[보안\]**

메시지 큐에 접근할 수 있는 마이크로서비스들에 대하여 보안 정책을 구성하여야 합니다. 메시지큐는 생산자와 소비자가 메시지 큐에 허용되지 않은 서비스들 혹은 외부의 요청이 발생하였을 경우 이에 대하여 IP 허용, SSL 통신을 활용한 TLS를 구성하여 접근제한을 둘 수 있습니다. 
CSP의 경우 메시지큐로의 인증 및 엑세스를 제어하고 서버-클라이언트 메시지 암호화를 통하여 보안을 설정합니다.

- 라이프사이클 : 메시지가 계속 누적될 경우 메시지큐의 성능 저하, 장애를 유발할 수 있습니다.

- 필터링 : Pub/sub 패턴의 경우 게시/구독에 대한 일부 시스템은 필터링 데이터를 지원하므로 구독자의 경우 미리 지정된 기준과 일치하는 메시지만 확인이 가능합니다.

- 재전송 : 메시지의 발송 후 수신 실패 시 재전송 횟수를 정합니다. 재전송 횟수가 많을수록 메시지 큐의 성능 저하 및 대기열에 메시지가 누적되어 장애를 유발하기 떄문에 적절한 재전송 횟수를 지정하는 것이 필요합니다. 
반드시 전달되어야 하는 경우 재전송 횟수를 늘리기 보다는 Error 메시지 출력이나 rollaback을 수행할 수 있도록 마이크로서비스를 개발하여야 합니다.

- 라우팅 : point-to-point 메시지 큐 패턴을 적용한 시스템의 경우 메시지에 대한 라우팅을 고려하여야 합니다.

- 일괄 처리 : 메시지가 메시지 큐에서 바로 처리되어야 하는지 아니면 다수의 큐가 쌓일 때까지 대기하였다가 한번에 전송할지 정의하여야 합니다.

- 대기열 : 메시지 큐에서 메시지는 처리되고 삭제되기 전까지 대기열로 가게 됩니다. 이때 메시지가 대기열에 있는 경우에 메시지를 대기열로 보낼지 아니면 일정 개수의 메시지가 존재할 때 메시지 대기열에 넣을지 아니면 모든 대기열에 메시지를 넣을지 전달되는 메시지에 대한 대기열을 지정하여야 합니다. 각 메시지는 하나의 소비자가 한 번만 처리하도록 합니다.

- FIFO, 표준대기열 : 표준 대기열은 작업당 무제한의 트랜잭션 (TPS)를 지원하며 최소 1회의 메시지 전송을 지원합니다.
메시지의 순서에 대해서 정렬 기능은 제공하더라도 전송한 순서와 동일한 순서로 전송되지 않을 수도 있습니다. 예를 들어 short polling 방식의 경우 메시지 큐에 메시지가 A-B-C-D의 순서로 들어오게 되면 메시지 큐는 분산된 메시지 큐들에 각각 들어가게 되고 분산된 메시지 큐에서는 메시지를 보낼 때 A-B-C-D 순이 아닌 polling 요청이 먼저 온 메시지 큐에서 메시지를 발송하게 되므로 A-C-D-B의 순으로도 메시지의 전송이 이루어질 수 있습니다. 

- FIFO 방식은 정확히 1회의 메시지 처리를 제공하며 메시지 송신 및 수신 순서에 맞춰서 반드시 메시지를 보내게 됩니다. 작업 및 이벤트 순서가 중요한 메시지들이 있을 경우, 적용하며 중복을 허용하지 않아 각 마이크로서비스간의 메시징을 강화해줍니다. 각 메시지 내부에는 중복 전송을 제거하기 위한 유니크한 ID가 존재하며 전송시에 해당 ID를 확인합니다.

- 비용 : 모놀리식 아키텍처에서 메시지큐를 활용하지 않았을 경우 하나의 트랜잭션에 대한 네트워크 트래픽이 발생합니다. 
마이크로서비스 아키텍처에서 메시지큐를 도입하였을 때는 네트워크 트래픽이 메시지큐를 한번 더 거쳐서 서비스간의 통신이 발생하기 때문에 네트워크 트래픽 비용이 증가하는 이슈가 발생합니다. ( CSP의 경우 발송 건마다 요금 차감 )

- 부인 방지 : 게시자는 일부 또는 모든 가입자가 메시지를 수신하였는지 확인이 필요합니다. 수신이 확인되지 않을 경우 메시지가 재전송 혹은 대기하게 되므로 시스템의 성능에 대하여 영향을 미친다.

# 모노리스에서 마이크로 서비스로의 전환

모노리스 시스템을 마이크로 서비스로 분리하기 위해서는 다음과 같은 방법들을 고려 하여야 한다. 
 
1. API 를 어떻게 통합할 것인가?
2. 객체 참조를 어떻게 할 것인가?
3. 어떻게 (다시) 상호 연동시킬 것인가?
4. 중복된 기능과 데이터를 어떻게 할 것인가?
5. 서비스 분리에 따른 통합인증은 어떻게 할 것인가?

![](/img/03_Bizdevops/04/05/03_04_05_01.png)  


## **1. API 를 어떻게 통합할 것인가?**

모노리스 시스템에서는 서비스가 1개이기 때문에 ui 에서 api 를 호출할때 특정 ip 혹은 domain 을 호출하였었다. 그러나 마이크로 서비스에서는 서비스가 쪼개져서 각자의 ip 를 가지고, 개별 서비스는 scale out(확장) 가능하기에 여러 ip 들과 서비스를 매핑시키는 **Service Registry** 가 꼭 필요하다. 또한 ui 에서 호출을 할때는 하나의 ip 혹은 domain 만 호출을 할 수 있도록 진입점을 통일해주는 **Gateway** 가 필요하다.  

백엔드에서 통합과 분리가 이루어 진다고 하여도, 프론트엔드의 코드는 유지가 되어야 한다. 프론트는 우리가 만든 ui 일수도 있지만 우리의 서비스를 사용하고 있는 3rd party 어플리케이션일 수도 있다. 힘이 막강한 회사가 아니고서야 우리의 Api 주소가 변경 되었다고 각자의 서비스를 변경해 달라고 요청을 할 수는 없다. 혹시 변경되더라도 기존의 하위 호환성은 유지하여 api 를 설계 해야하기 때문에, 변경되는 서비스 최 상단에 proxy 를 두어서 api 패턴을 유지하는게 좋다. 여기에 사용되는 proxy 가 **Gateway** 이다.  

**Gateway** 는 진입점 통일 역활을 하여 마이크로 서비스를 찾아가는 라우팅 역할을 한다.  
또한 마이크로 서비스의 최상단에서 갑옷을 입는 역할을 한다. 보안(e.g: prevent DDOS Attack) , 인가(e.g: Access Token), ACL(Access Control List), CORS(Cross-Origin Resource Sharing) 등을 각자의 서비스에서 처리를 하지 않고, **Gateway** 에서 일괄적으로 처리를 함으로서 마이크로 서비스에서는 구현에 좀더 집중을 할 수 있는 환경을 만들어 준다.  

> Gateway 의 자세한 설명은 [[operation/API Gateway]](../07_operation/02_API%20Gateway) page 에서 참고 하면 된다.    


**Service Registry** 는 **Gateway** 에서 각 서비스를 찾아 갈 수 있도록 서비스와 ip 를 가지고 있는 맵 이라고 볼 수 있다. 
Service Registry 는 client/server side discovery , loadbalancer 라고 불리운다. 서비스를 찾고, 로드벨런싱 하는 역할을 한다.  

> Service Registry 의 자세한 설명은 [[implementation/Service Registry]](./06_Service%20Registry) page 에서 참고 하면 된다.    

## **2. 객체 참조를 어떻게 할 것인가?**

쇼핑몰 시스템의 예를 들어보면 기존 모노리스에서는 주문을 할 때, 상품 객체를 바로 사용하였었는데, 서비스를 분리하고 나니 객체가 없는 문제가 발생한다. 즉 직접적인 메모리 기반 객체 참조는 불가능 하여 졌다. 이럴때 해결하는 방법은 **Shared-Kernel** 방법을 사용 할 수 있다.    

* 중복된 객체를 생성

    그러나 마이크로 서비스의 장점은 polyglot 환경에 있는데 Shared-Kernel 방법은 동일 언어에서만 사용 가능한 방법이다. Java 와 Python 시스템은 Shared-Kernel 이 성립을 할 수가 없다. 이럴때는 **중복된 객체를 생성** 하면 된다. 중복된 객체 생성을 할때 장점은 기존의 수많은 항목들은 필요가 없고, 내가 필요한 정보만 내가 파싱하여 사용할 수 있다. 

* 분리된 Aggregate 내부의 Entity 간에는 Key 값으로만 연결
    - Primary Key 를 통해서만 참조
    - HATEOAS link 를 이용
    
    객체를 중복 생성 하기 싫다면, 기존의 원격 호출 처럼 api 를 호출하여 파싱해서 가져 올 수 밖에 없다.  
    어그리게이트가 나누어져 있다는 것은 런타임과 트랜젝션이 다르다는 의미인데, 이럴때는 **Primary Key** 로 구분을 해야한다.
    혹은 **HATEOAS link 를 이용하여 객체를 참조** 할 수 있다. 다만 모든 api 를 HATEOAS 수준으로 메니징 하는 것은 높은 비용이 요구된다. 
    
    Entity 간에 Primary Key 를 이용하여 객체 참조를 할때 Aggregate Root 를 통해서만 호출을 하는 것이 좋다. Aggregate 는 수많은 Entity 를 포함하는데 그중 대표격인 것이 Aggregate Root 이다. 예를 들어 상품 이라는 Aggregate 가 있을때 속성으로는 상품 디테일, 재고, 가격비교 등을 하위 Aggregate 로 가지고 있을 수 있다. 이때 재고 라는 Aggregate 를 객체를 바로 외부에서 호출 하여 CUD 가 일어나게 된다면 데이터가 일그러지는 경우가 생긴다. 재고라는 Aggregate 를 객체를 접근 하고 싶을때는 상품이라는 Aggregate Root 를 통하여 호출하는 채널을 일원화 시켜야 한다.  
    
## **3. 어떻게 (다시) 상호 연동시킬 것인가?**


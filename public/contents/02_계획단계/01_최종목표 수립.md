## 최종목표 수립

마이크로서비스는 **MSA 아키텍처**를 적용해 시스템을 구현한 것으로 완성되는게 아니라, 구축된 시스템을 운영할 Cross-functional 한 **조직**, 그리고 안정적으로 시스템을 개선하고 배포하는데 필요한 **데브옵스 환경**이 조성되어야 하는데, 이 3 요소를 **'MSA 트라이앵글'** 이라 한다.

<br/>

### MSA 트라이앵글 모형

마이크로서비스 아키텍처는 서비스간 배포 단위를 분리하는 방법으로 상호 간섭을 줄이고, 개별 서비스의 확장이 가능하도록 해 준다.  

이러한 MSA는 도입하려는 기업 내 IT부서 만의 노력으로는 결코 정착될 수 없다. 왜냐하면 MSA는 기술이 아닌, ‘시장 변화와 고객의 요구에 민첩하게 대응하는 경영방식’이며, ‘기업 문화’이기 때문이다. 

마이크로서비스 아키텍처를 활용할 수 있는 서비스 단위의 조직 구성이 이루어지고, 이러한 조직들이 DevOps 환경에서 자율적으로 운영될 때, 비로소 MSA가 기업 문화로 자리매김 할 수 있는 것이다.

![](/contents/02_계획단계/01/image1.jpg)

마이크로서비스 기반 DevOps는 개발 생산성 및 배포 유연성을 높여 비즈니스 변화에 민첩하게 대처할 수 있는 운영 환경이다. 이는 MSA 트라이앵글의 3 요소가 상호 유기적으로 연계될 때, 가능하다는 것을 유념해야 한다.

<br/>

### 12st 쇼핑몰 Goal

예제 도메인 12st 쇼핑몰 미션인 **"Service Resiliency, Customer Responsiveness, Scalability"** 를 달성하기 위한 각 단계별 세부 목표는 다음과 같다. 

<br/>
<div style="text-align: center;">

![](/contents/02_계획단계/01/image2.jpg "시스템 구현 모형") 
_[E-Commerce 시스템 구현모형]_
</div>

API Gateway 는 유입되는 요청에 대해 인증 정보를 확인 후 각 마이크로서비스로 라우팅 한다.  

주문, 상품, 배송 서비스들은 중앙의 메시지 큐(Kafka)를 통해 이벤트 기반 Pub/Sub 방식으로 통신하되, 필요 시 REST 기반 직접 호출도 수행한다. 이때, 여러 서비스의 복합 정보를 서비스 해야하는 '마이페이지'는, 여러 이벤트를 Subscribe 하여 데이터를 프로비저닝 한다.  

<br/>

## MSA 성숙도 모델 & 적용 레벨 

MSA 아키텍처는 서비스 독립성, 데이터 분리성, SW 아키텍처 수준에 따라 4 단계(Early, Inception, Expanding, Mature)로 구분한다.

12st 쇼핑몰의 구현 관점별 MSA 성숙도 적용 레벨은 다음과 같다. (노란색 표시)    

<h5>
<table>
<tbody>
<tr>
<td width="12%" align="center">구현 관점</td>
<td width="22%" align="center"><strong>Early (Lv1)</strong></td>
<td width="22%" align="center"><strong>Inception (Lv2)</strong></td>
<td width="22%" align="center"><strong>Expanding (Lv3)</strong></td>
<td width="22%" align="center"><strong>Mature (Lv4)</strong></td>
</tr>
<tr>
<td align="center"><p><strong>기능</strong></p>
<p><strong>분해</strong></p></td>
<td>기능과 유즈케이스 단위로 분리<br />
- 비즈니스 역량은 도출한 비즈니스 기능과 유즈케이스 단위로 분리가능</td>
<td>서비스별 인터페이스 정의<br />
- 추출 된 각 유스 케이스와 인터페이스를 통해 액세스 할 데이터에 대해 잘 정의 된 인터페이스를 가짐.</td>
<td><p>도메인 Context 분리</p>
<p>Ubiquitous language 가 다른 bounded context간의 커뮤니케이션 시, Anti-corruption layer를 통해 수행</p></td>
<td bgcolor="yellow">도메인 기반 이벤트<br />
- 구체화된 보기, 읽기 쓰기를 위한 별도의 모델(CQRS) 구축</td>
</tr>
<tr class="odd">
<td align="center"><strong>데이터</strong></td>
<td>2PC 사용 가능<br />
- ACID 기반의 트랜잭션을 유지한다. Canonical Data Model 를 지향</td>
<td><p>Scheme per Service</p>
<p>- 각각의 서비스는 자신만의 Scheme를 가짐<br />
- 서비스들과 다중 엔터프라이즈 데이터 저장소 간의 트랜잭션이 적은 조정으로 이루어짐</p></td>
<td><p>DBMS per Service</p>
<p>- 완전히 분산된 데이터 관리<br />
- 서비스별 다른 유형의 DBMS 사용이 가능한 폴리글랏 퍼시스턴스를 지향</p></td>
<td bgcolor="yellow"><p>Event-Driven Archi.</p>
<p>- 이벤트 기반 데이터 관리, 이벤트 소싱 및 커멘드 쿼리<br />
- 일시적으로 데이터에 일관성이 없는 상태가 존재할 수 있으나, 일정 시간이 지나면, 데이터가 도착하여 다시 Consistency를 충족</p></td>
</tr>
<tr class="even">
<td align="center"><strong>SW<br />
아키텍처</strong></td>
<td>UI/UX : Server Side rendering,<br />
Session based 보안,<br />
단일 언어(eg. Spring framework)</td>
<td>UI/UX : Server Side rendering,<br />
Session cluster 적용,<br />
MSA 지향 언어(eg. Spring Boot)</td>
<td>UI/UX : Client Side rendering,<br />
Token based 보안, OAuth2,<br />
폴리글랏 Language</td>
<td bgcolor="yellow">UI/UX : Client Side rendering+MVVM,<br />
Token based 보안, OAuth2,<br />
폴리글랏 Language + Service Mesh</td>
</tr>
<tr class="odd">
<td align="center"><p><strong>Infra</strong></p>
<p><strong>스트럭처</strong></p></td>
<td>지속적인 빌드, 지속적인 통합 운용</td>
<td>지속적인 딜리버리와 배포, 로그의 중앙 집중화</td>
<td>컨테이너 사용(도커), 컨테이너 오케스트레이터(k8s), 외부 구성(유레카, 주키퍼)</td>
<td bgcolor="yellow">자동 프로비저닝을 갖춘 PaaS기반 솔루션</td>
</tr>
<tr class="even">
<td align="center"><strong>배포</strong></td>
<td>설치 스크립트 구동, 호스트 당 멀티 서비스 인스턴스</td>
<td>VM 당 하나의 서비스 인스턴스<br />
클라이언트 사이드 로드 벨런싱<br />
서버사이드 로드 벨런싱</td>
<td bgcolor="yellow">Immutable 서버, 컨테이너 당 하나의 서비스 인스턴스, blue/green 배포</td>
<td>멀티 클라우드 및 멀티 데이터 센터 지원</td>
</tr>
<tr class="odd">
<td align="center"><strong>팀구조</strong></td>
<td>개발, QA,릴리즈, 운영이 분리된 하나의 기능 팀</td>
<td>공유된 서비스 모델로 팀 공동 작업<br />
내부 소스 공개</td>
<td><p>서비스별 프로덕트 팀(PO, UI/UX 디자이너, 개발자)</p>
<p>Cross Functional한 플랫폼 팀</p></td>
<td bgcolor="yellow">업무 기능별 혹은 도메인별 팀들이 모든 관점에서 책임을 수반. &quot;네가 구축한 것은 네가 운영한다.&quot;</td>
</tr>
</tbody>
</table>
</h5>

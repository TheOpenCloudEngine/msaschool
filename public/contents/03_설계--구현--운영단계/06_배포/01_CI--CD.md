## CI/CD

**CI/CD** 는 어플리케이션의 개발부터 제공 및 배포단계를 자동화 하여 고객에게 짧은 주기에 제공하는 방법입니다. **CI/CD**의 기본 개념은 지속적인 통합(Continuous Integration), 지속적인 서비스 제공(Continuous Delivery), 지속적인 배포(Continuous Deployment)입니다. 

#### 지속적인 통합(Continuous Integration)

**CI/CD**의 "CI"는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미합니다. 이것은 모든 개발이 끝난 후에 코드 품질을 관리하는 고전적인 방식의 단점을 해결하기 위하여 나타났습니다.  

예를 들어 개발자 10명이 초기 프로젝트를 git clone 받아서, 각자 개발을 한 후에 한달 후에 코드를 통합 한다고 가정하여 보겠습니다. 개발을 조금 해보신분이라면, 코드가 충돌났을때 얼마나 끔찍한지 다들 경험해 보셨을 것입니다. 심지어 한달동안 개발한 내용이라면 엄청 날텐데.. 생각만 해도 통합하는데만 시간이 오래 걸릴것 같습니다. 이런 문제를 해결하려면 통합 주기를 빠르게 해야 합니다. 
또한 소스코드 통합시 어플리케이션이 정상작동을 안할수도 있습니다. 누군가가 내가 만들었던 코드에 기능을 추가 했는데, 그 기능때문에 원하던 정확히 원하는 결과가 안나올수도 있습니다. 
이런 문제를 해결 한다고, 매일 병합 작업을 하고 정확한 결과를 확인하기 위하여 테스트 작업을 "수작업으로" 한다면 많은 시간이 필요할 것입니다.  

이렇게 **개발코드를 통합할때의 문제점을 해결하고 자동화 시켜 지속적으로 유지 시키는 방법**이 **"CI"** 입니다. 개발자가 코드를 커밋만 치면 자동으로 빌드, 통합을 하고, 테스트를 하는 과정을 의미합니다.  


#### 지속적인 서비스 제공(Continuous Delivery), 지속적인 배포(Continuous Deployment)

CI/CD의 "CD"는 **지속적인 서비스 제공**(Continuous Delivery) 또는 **지속적인 배포**(Continuous Deployment)를 의미합니다. 어플리케이션을 항상 신뢰 가능한 수준으로 배포 될수 있도록 지속적으로 관리하자는 개념입니다. 두 가지 의미 모두 파이프라인의 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 합니다.

![](/img/03_Bizdevops/06/cicd01.png)
> 그림 : https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment

**지속적인 서비스 제공**(Continuous Delivery)은 CI 프로세스를 통과 하는 모든 코드 변경 내용은 프로덕션 환경과 유사한 환경에 자동으로 게시하는 과정입니다.

**지속적인 배포**(Continuous Deployment)는 앞의 두 과정을 프로덕션 환경까지 자동 배포 혹은 의사결정에 의한 배포 할수 있는 환경을 구성하여 놓는 것입니다.

약간의 자동화 단계의 차이는 있지만 결국 **"CD"** 는 **CI 가 이루어지고 난 후에 운영환경 까지의 배포를 하여, 실제 사용자가 사용할수 있겠끔 하는 단계**입니다. 만약 CI/CD 가 자동화 되어 매일 개발 환경에 그날그날 개발한 내용이 배포가 된다면 개발팀과 비지니스 팀과의 의사소통은 활발해 질수 있을 것이고, 바로바로 피드백을 수정 할 수 있을 것입니다. 피드백을 받아서 문제가 있을 경우 빠르게 이전 버전으로 롤백을 하는 과정도 자동화에 포함 시킬수 있습니다. 또한 배포를 운영팀이 수동으로 하고있었다면, 자동화를 통하여 운영팀의 부하를 줄여 줄 수 있습니다. 

> 참고 : https://www.redhat.com/ko/topics/devops/what-is-ci-cd

<br/>

## 마이크로 서비스에서 CI/CD

#### 모노리식 개발 및 운영환경

![](/img/03_Bizdevops/06/ProcessChange1.png)

모놀리식 아키텍쳐로 구성된 애플리케이션의 경우 빌드 과정까지 단일 빌드 파이프 라인을 가지고 있습니다. 
큰 개발팀이 하나의 소스코드 레파지토리에 변경 사항을 커밋하므로 코드간 상호 의존도가 높습니다. 레파지토리가 하나이기 때문에, 여러 팀중 1개의 팀에서 버그가 나올 경우 버그 수정 후 전체 어플리케이션에 통합 하고, 테스트 후 배포를 해야하기 때문에 서비스의 릴리스에 시간이 많이 필요합니다. 또한 작은 변경에도 전제를 다시 테스트/ 배포하는 구조이므로 통합 스케줄에 맞춘 파이프 라인을 적용하기가 어렵습니다.

#### 마이크로서비스 개발 및 운영환경

![](/img/03_Bizdevops/06/ProcessChange2.png)

마이크로 서비스 기본 원칙을 따르면 모든 팀이 줄을 서야 하는 긴 릴리스 기차가 없어야 합니다. 서비스 "A"를 빌드하는 팀은 병합, 테스트 및 배포될 서비스 "B"의 변경 내용을 기다릴 필요 없이 언제든지 업데이트를 릴리스할 수 있어야 합니다. 

* 작고 분화된 조직에서 서비스를 작은 크기로 나누어 개발하므로 해당 비즈니스 로직에만 집중하게 되어 개발 생산성 향상됩니다.
* 연관된 마이크로서비스만 테스트를 수행하므로 개발/테스트/배포 일정이 대폭 축소됩니다.

이를 이렇게 표현을 할 수 있습니다. "기차를 타지 말고 택시를 타라". 모든 칸이 다 채워질때까지 기다려야 하고, 메인 기능이 타야 출발 할 수있는 기차를 타지 말고, 각자 택시를 잡고 빠르게 목적지에 도착을 하라는 말입니다. 

하지만 택시를 탈때도 규칙은 있어야 합니다. 다른 팀과의 테스트를 안하고 개별적으로 배포를 하지만, 팀간의 규칙이 있다면 (예: api 규약) 규칙은 지키면서 배포가 되어져야 합니다. 마이크로 서비스에 이러한 테스트 방법이 **컨트렉트 테스트** 라고 합니다. 또한 자기 팀의 배포는 자기가 책임 져야 하기때문에, 잘못된 업데이트로 인한 문제 생성시 즉각적으로 기존 버전으로 롤백할 수 있는 신뢰성 있는 방법이 있어야 합니다.

<br/>

## CI/CD 도구

소스코드부터 운영 환경에 자동적으로 Delivery 를 하기 위해서 다양한 도구들이 존재 합니다. 각 도구마다 장단점이 있고, 매년 새로운 기술들이 나오기 때문에 어떤것이 정답이다라고 말을 할 수는 없습니다. 또한 CI 에 특화된 툴 (예: Travis CI) CD 에 특화 된 툴 (예: Spinnaker) 도 존재합니다. 그리고 각 클라우드 벤더사에서도 Managed Service (Azure Pipeline, Cloud Build 등) 로 CI/CD 도구를 자체 지원하기도 합니다. 

![](/img/03_Bizdevops/06/cicd03.png)

위 그림은 DevOps 의 대표적인 toolchain 입니다. 
CI 에서 소스코드 형상 관리는 필수적인 요소 입니다. 최근에 가장 많이 사용하는 형상 관리는 Git 입니다. 
마이크로 서비스의 아키텍처의 장점을 최대한 살리고, 빌드된 소스 코드를 개발환경이나 운영환경으로 서로 다른 환경에 변함없이 기동할수 있는 기술을 Containerization (컨테이너화) 라고 합니다. 이 컨테이너 기술의 대표 프로그렘이 Docker 입니다. 
배포 환경으로는 2017년 이후로 Kubernetes 가 가장 많이 사용되고 있습니다. Kubernetes 는 컨테이너를 실은 배의 선장같은 역할로 종합적인 컨테이너 인프라를 제공하여 줍니다.

더욱 다양한 도구들은 https://landscape.cncf.io/ 에서 확인 할 수 있습니다.  

![](/img/03_Bizdevops/06/cicdTool03.png)
 
<br/>

## 컨테이너 오케스트레이션 Lab. Guide 

<br/>

### 구글 (Google) Cloud
<details>
<summary>Google Cloud Platform 기반의 Container Orchestration Lab. Scripts</summary>
<p>

<details>
  <summary><b>자주 사용되는 GCP Cloud 명령어</b></summary>

  - <b>Referencing URL: https://cloud.google.com/kubernetes-engine/docs/how-to/managing-clusters?hl=ko</b>
  - <b>GCP 인증</b>
    - gcloud init

  - <b>GCP 클러스터 생성</b>
    - gcloud container clusters create (Cluster Name) --zone asia-northeast1-a --enable-cloud-logging --enable-cloud-monitoring --subnetwork default

  - <b>GCP 클러스터 토큰 가져오기</b>
    - gcloud container clusters get-credentials (Cluster Name) --zone asia-northeast1-a --project (PROJECT-NAME)

  - <b>GCP GCR(Google Container Registry) 인증</b>
    - gcloud auth configure-docker
  - <b>GCR 레지스트리에 이미지 Push</b>
    - docker push gcr.io/PROJECT-NAME/IMAGE-NAME:v1
    - (docker  version 18.03 이하)
    - gcloud docker -- push gcr.io/PROJECT-NAME/IMAGE-NAME:v1
    - 오류(unknown flag: --password-stdin) 발생 시,
      - docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/
  - <b>GCP 클러스터 삭제</b>
    - gcloud container clusters delete [CLUSTER_NAME]

    
</details> 
    
### Docker

<details>
<summary><b>Docker Hands-on</b></summary>

  - <b>Lab. image</b>
    - 이미지 Pull
      - docker pull hello-world
      - docker images 
      - docker pull nginx
      - docker pull nginx:latest
      - docker pull docker.io/library/nginx:latest
      - docker pull nginx:1.16.1
      - docker images
    - 도커허브 (Docker Hub, 가입) 
      - http://hub.docker.com # 접속 후, nginx 검색 
    - 이미지 Tagging
      - docker image tag nginx my-nginx # Create 태그
    - 이미지 삭제
      - docker image rm my-nginx
      - docker image rm hello-world
      - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
      
  - <b>Lab. container</b>
    - 컨테이너 생성
      - docker run hello-world # 컨테이너 만들기
      - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
      - docker run --name my-nginx -d -p 8080:80 nginx
      - docker ps
    - 컨테이너 시작/종료
      - docker stop my-nginx
      - docker start my-nginx
    - 컨테이너 포트 노출
      - http://localhost 에서 nginx index.html 확인
      - docker container rm my-nginx
      - docker run --name my-nginx -d -p 8080:80 nginx
      - http://localhost:8080 에서 nginx index.html 확인
    - 컨테이너 접근
      - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
      - docker exec -i -t  my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - curl localhost
        - exit
    - 컨테이너 삭제
      - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
      - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
  - <b>Lab. Docker Build & Push</b>
    - Dockerfile 로부터 이미지 생성
      - Dockerfile & 리소스 생성
        - mkdir Dockerfile
        - cd Dockerfile
        - nano index.html
          "Hi~ My name is Park Yong Joo.."
        - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
        - nano Dockerfile
          "FROM nginx
          COPY index.html /usr/share/nginx/html/"
        - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
      - 도커라이징 & Docker Hub에 Push
        - docker build -t (Docker-ID)/my-nginx . 
        - docker images
        - docker push (Docker-ID)/my-nginx
          "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
      - http://hub.docker.com 에서 이미지 확인
      - Docker Hub 이미지로부터 컨테이너 실행
        - docker run --name new-nginx -d -p 8081:80 (Docker-ID)/my-nginx
      - Browser에서 실행 애플리케이션 확인
        - http://localhost:8081
  - <b>Clear</b>
    - docker container rm $(docker ps -a -q)
      - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
      - docker container stop new-nginx
    - docker image rm -f $(docker images -q)
    
</details> 

### Kubernetes

<details>
<summary><b>Kubernetes Hands-on</b></summary>

- <b>Cloud Shell에서 Docker hub 토큰 생성 (docker hub의 접속정보 입력)</b>
  - docker login 
- <b>Kubernetes Hands-on</b>
  - Lab에 필요한 리소스 내려받기
    - git clone https://github.com/event-storming/container-orchestration.git
    - cd container-orchestration
    - cd yaml
  - Lab. K8s Sample App 생성
    - 어플리케이션 생성/ 확인
      - Docker hub에 올린 이미지를 통한 컨테이너 생성
        "kubectl create deploy my-nginx --image=apexacme/my-nginx:v1"
      - 클러스터 외부에 노출하기
        "kubectl expose deploy my-nginx --type=LoadBalancer --port=80"
    - 서비스 확인하기
      - kubectl get svc의 EXTERNAL-IP 복사
      - Browser에서 EXTERNAL-IP:80 접속

  - Lab. Pod & 기본명령
    - kubectl get nodes
      - 쿠버네티스에 제대로 접속했는지 확인
      - 현 클러스터의 워크노드를 리스트업
      - 접속 결과 안나오는 경우
        - kubectl config current-context 명령으로 Cluster 접속 확인
    - 객체의 검색
      - kubectl get [object type]
      - kubectl get pods   # pods = pod = po
      - kubectl get deployments   # deploy
      - kubectl get services    # svc
      - kubectl get replicaset    # rs
    - 객체의 모니터링
      - watch kubectl get all
      - kubectl get pod -w
      - watch kubectl get pod
    - 객체의 유형
      - Service 
        - types
          - LoadBalancer
            - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
            - front-end 혹은 ingress (api gateway)
          - ClusterIP(default) / NodePort
            - 클러스터 내부 IP
            - 내부 마이크로 서비스
      - Deployment
        - ReplicaSet (하나이상 생성)
          - Pod (하나이상 생성)
            - Container (docker ) 하나이상.
      - Pod
      - ReplicaSet
      - Ingress
      - Secret
      - ConfigMap
      - ServiceAccount = sa
      - statefulset
      - daemonset
    - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
      - nano declarative-pod.yaml
        "apiVersion: v1
        kind: Pod
        metadata:
          name: declarative-pod
          labels:
            env: test
        spec:
          containers:
          - name: my-first-
            image: nginx"
      - 저장 및 종료 (ctrl + X, Y, 엔터)
      - kubectl create -f declarative-pod.yaml
      - kubectl get pods
    - 원하는 Node 타입에 Pod 생성
      - pwd 명령으로 현 위치가 /container-orchestration/yaml/pod 인지 확인
      - kubectl create -f pod-with-nodeselector.yaml
      - kubectl get po -o wide
        - Pod가 찾는 노드가 없어 pending 상태
      - 노드에 라벨 추가
        - kubectl label nodes [your-node-name] disktype=ssd
        - kubectl get nodes --show-labels | grep ssd
      - kubectl get po -o wide
    - 생성된 Pod 및 오브젝트 삭제
      - kubectl delete pod [pod명]
      - kubectl delete service,deploy --all
  - Lab. Label 
    - kubectl run nginx --image=nginx
    - kubectl get pods -l app=nginx
    - kubectl get pods --selector app=nginx
    - kubectl get pods --selector 'app in (nginx, test)'
  - Lab. ReplicaSet
    - pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인
    - kubectl create -f replicaset.yaml
    - kubectl get all
    - #replica 개수 조정
      - kubectl scale replicaset/frontend --replicas=5
      - kubectl get po 
  - Lab. Deployment & 기본명령 
    - 기본 nginx 서버의 배포
    - kubectl create deploy nginx --image=nginx
    - kubectl get deploy nginx
    - kubectl get replicaset -l app=nginx
    - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
    - kubectl get pods --selector app=nginx
    - kubectl get pods --selector 'app in (nginx, test)'
    - kubectl describe po (검색한 pod name)
    - (pod 제거)
    - kubectl delete po --all   # 
    - (pod 를 제거해도 재생됨을 확인)
    - kubectl get po
    - (scale out)
    - kubectl scale deploy nginx --replicas=3
    - kubectl get po   # pod 개수가 3개로 늘어남을 확인
    - kubectl delete po --all   # pod 를 모두 지움
    - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
    - ( 제거하기 위해서는 deployment 를 제거해야만 함)
    - kubectl delete deploy nginx
  - Lab. Rollout & Back
    - (pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)
    - kubectl create -f nginx.yaml
    - (배포주석 확인, 주석이 없을 경우 아래 명령으로 주석 추가( Rollback시, 필요) ) 
    - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
    - (설정의 변경)
    - 파일을 편집기에서 열어(nano nginx.yaml) spec > replicas 부분을 3-->5 로 수정
    - kubectl apply -f nginx.yaml
    - (스케일 아웃 결과 확인)
    - kubectl get deploy     # DESIRED :3 --> 5 로 수정되고 곧 ACTIVE 도 5가 됨
    - (무정지 버전업)
    - 파일을 편집기에 열어서(nano nginx.yaml) spec > template > image 부분을 nginx:1.7.9 -> nginx:1.9.1 로 수정
    - kubectl apply -f nginx.yaml
    - (배포주석 달기)
    - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is nginx:1.9.1'
    - (결과확인)
    - kubectl describe po <해당 deployment 의 pod 중 하나의 이름>    # 내용의 image 부분이 1.791 인지 확인
    - (무정지 재배포 히스토리 확인)
    - kubectl rollout history deploy nginx-deployment
    - (다음과 같이 출력됨을 확인)
      "REVISION  CHANGE-CAUSE
      1         v1 is nginx:1.7.9
      2         v2 is nginx:1.9.1"
    - (롤백하기)
    - kubectl rollout undo deploy nginx-deployment
    - kubectl rollout undo deployment nginx --to-revision 1
  - Lab. Service
    - kubectl delete service,deploy --all  # 기존 이력 삭제 
    - (다시 생성)
    - kubectl create deploy nginx --image=nginx
    - (서비스로 노출)
    -  kubectl expose deploy nginx --type="LoadBalancer" --port=80
    - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
    - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
  - Auto Scale-Out 
    - pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인
    - (모든 객체 지우기)
    - kubectl delete deploy,service,pod --all
    - (대상 서비스 배포 및 모니터링)
    - kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
      - NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함
        " resources:
            limits:
              cpu: 500m
            requests:
              cpu: 200m"
    - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
      - kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10
        "cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)"
      - kubectl get hpa php-apache -o yaml
    - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
      - cat siege.yaml
      - kubectl create -f siege.yaml
    - 로드 생성
      - siege -c30 -t30S -v http://php-apache
    - (오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)
      - metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인 
      - 디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인
      - cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음
  - Lab. Volume
    - (pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)
    - (emptyDir 마운트)
    - kubectl create -f volume-emptydir.yaml
      - kubectl exec -it shared-volumes --container redis -- /bin/bash
      - cd /data/shared
      - echo test… > test.txt
      - exit
      - kubectl exec -it shared-volumes --container nginx -- /bin/bash
      - cd /data/shared
      - ls
    - (GitRepository를 볼륨으로 마운트)
    - kubectl create -f volume-gitrepo.yaml
    - (PersistentVolumeClaim 생성)
    - kubectl create -f volume-pvc.yaml
    - kubectl get pvc 
    - kubectl describe pvc azure-managed-disk
    - (생성된 PersistentVolueClaim으로 Pod 생성하기)
    - kubectl create -f pod-with-pvc.yaml
    - kubectl describe pod mypod
    - (포드 접속)
    - kubectl exec -it mypod -- /bin/bash
    - (마운트 및 사이즈 확인)
    - df -k
  - Lab. ConfigMap
    - (pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)
    - (컨피그 맵 생성)
    - kubectl create configmap hello-cm --from-literal=language=java
    - kubectl get cm
    - kubectl get cm hello-cm -o yaml
    - 클라우드에서 배포 이미지 확인
    - nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)
    - (배포 및 서비스 생성)
      - kubectl create -f cm-deployment.yaml
      - kubectl create -f cm-service.yaml
    - (서비스 확인)
      - Service의 External-IP 접속
  - Lab. Secret
    - (pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)
    - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
  - Lab. Liveness & Readiness Probe
    - (pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)
    - (Liveness Command Probe 실습)
      - kubectl create -f exec-liveness.yaml 
      - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
      - (kubectl describe로 실패 메시지 확인)
      - kubectl describe po liveness-exec
    - (Liveness HTTP Probe 실습)
      - kubectl create -f http-liveness.yaml
      - (kubectl describe로 실패 메시지 확인)
      - kubectl describe po liveness-http
    - (Liveness 와 readiness probe 동시 적용 실습)
      - kubectl create -f tcp-liveness-readiness.yaml
      - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
      - kubectl describe po goproxy
  - Lab. Ingress
    - Helm(패키지 인스톨러) 설치
      - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
      - (설치 중, sudo를 위한 비밀번호 입력) 
      - (Helm 초기화 설정)
        - (Helm 설치 관리자를 위한 시스템 사용자 생성)
        - kubectl --namespace kube-system create sa tiller 
        - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
        - (kubectl config current-context 명령으로 클러스터명 확인)
        - (helm version 3.x 이상에서는 init 불필요)
        - (helm version 2.x under Only) helm init --kube-context (나의 Azure 클러스터 명) --service-account tiller
        - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
        - helm repo update
    - Helm으로 Ingress Controller 설치
      - kubectl create namespace ingress-basic
      - (helm version 3.x 이상에서는 --name 옵션 불필요)
      - (helm version 2.x under) helm install --name nginx-ingress stable/nginx-ingress --kube-context=(MyAKSCluster) --namespace=ingress-basic
      - (helm version 3.x higher) helm install  nginx-ingress stable/nginx-ingress --namespace=ingress-basic
      - (설치확인)
        - kubectl get all --namespace=ingress-basic
        - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
    - Ingress 대상 서비스(BLUE, GREEN) 생성
      - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
        - (도커라이징 & 이미지 Push)
        - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .
        - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
        - nano nginx-blue-deployment.yaml
        - (저장 ctrl + X)
        - (배포 및 서비스 생성)
        - kubectl create -f nginx-blue-deployment.yaml  
      - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
        - (도커라이징 & 이미지 Push)
        - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .
        - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
        - nano nginx-green-deployment.yaml
        - (저장 ctrl + X)
        - (배포 및 서비스 생성)
        - kubectl create -f nginx-green-deployment.yaml 
      - (서비스 생성 확인)
        - kubectl get deploy,service -n ingress-basic
    - Ingress 생성
      - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)
      - kubectl create -f web-ingress.yaml
      - (Ingress 생성확인)
      - kubectl get ingress -n ingress-basic
    - Ingress 테스트
      - API Gateway 주소를 Local 시스템에 등록
        - 관리자권한으로 CMD 실행
        - cd c:\
        - cd windows
        - cd system32
        - cd drivers
        - cd etc
        - notepad hosts
        - Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록   
          "예시. 51.243.10.185	 blue.example.com  green.example.com"
      - 인그레이스 리소스 삭제
      - kubectl delete namespace ingress-basic

</details>

<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>

- <b>Lab. Ingress</b>
  - Helm 명령으로 설치 여부 확인
  - Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
    - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
    - (설치 중, sudo를 위한 비밀번호 입력) 
    - kubectl --namespace kube-system create sa tiller 
    - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
    - helm init --service-account tiller
  - Helm으로 Ingress Controller 설치
    - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    - helm repo update
    - kubectl create namespace ingress-basic
    - helm version으로 버전확인
    - (helm version 2.x 일때)
    - helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic
    - (helm version 3.x 일때) 
    - helm install  nginx-ingress stable/nginx-ingress --namespace=ingress-basic
    - (설치확인)
      - kubectl get all --namespace=ingress-basic
      - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
  - Ingress 대상 서비스(BLUE, GREEN) 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-blue-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-blue-deployment.yaml  
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-green-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-green-deployment.yaml 
    - (서비스 생성 확인)
      - kubectl get deploy,service -n ingress-basic
  - Ingress Routing Rule 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)
    - kubectl create -f path-based-ingress.yaml
    - kubectl get ingress -n ingress-basic
  - Ingress 테스트
    - 인그레이스 리소스 삭제
      - kubectl delete namespace ingress-basic

</details>

<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>

  - <b>Lab. Istio Install</b>
    - Istio 설치
    - curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -
    - cd istio-1.7.1
    - export PATH=$PWD/bin:$PATH
    - istioctl install --set profile=demo
      "note : there are other profiles for production or performance testing."
    - Istio 모니터링 툴(Telemetry Applications) 설치
      - kubectl apply -f samples/addons
      - 모니터링(Tracing & Monitoring) 툴 설정
        - Monitoring Server - Kiali
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc kiali -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
        - Tracing Server - Jaeger
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc tracing -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80
    - 설치확인
      - kubectl get all -n istio-system
  - <b>How to enable Istio</b>
    - 1. Whenever deploying to Cluster, Using pre-processing command 'Istio kube-inject'
      - kubectl apply -f <(istioctl kube-inject -f Deployment.yml) -n istio-test-ns
    - 2. Using Istio-enabled Namespace.  
      - e.g. kubectl label namespace istio-test-ns istio-injection=enabled


  - <b>Lab. Istio Tutorial 셋업</b>
    - Git repository에서 Tutorial 리소스 가져오기
      - cd ~
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - 네임스페이스 생성
      - kubectl create namespace tutorial
    - Customer Service 배포
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
        - kubectl describe pod (Customer Pod) -n tutorial 로 생성확인
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
    - Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
      - cat customer/kubernetes/Gateway.yml 
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
      - (Istio-IngressGateway를 통한 Customer 서비스 확인)
        - kubectl get service/istio-ingressgateway -n istio-system
        - 해당 EXTERNAL-IP가 Istio Gateway 주소
        - Customer 서비스 호출 : 
          "http://istio-ingressgateway IP)/customer"
    - Preference, Recommendation-v1 Service 배포
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
  - <b>Lab. Istio - Traffic Routing</b>
    - Simple Routing
      - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
      - (recommendation 서비스 추가 배포: v2)
         - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
      - 서비스 호출
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
        - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
      - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
      - (Recommendation v.2 서비스 Scale Out)
      - (서비스의 v2 의 replica 를 2로 설정)
        - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
        - kubectl get po -n tutorial
      - Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출
      - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
    - Advanced Routing
      - 정책(VirtualService, DestinationRule) 설정
        - (현, 정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
        - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
          - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
        - (설정정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (서비스 확인)
          - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
          - Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링
      - 가중치 기반 스마트 라우팅 (Canary Deployment)
        - (recommendation 서비스 v1의 가중치를 100으로 변경)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
        - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
          - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - Canary 라우팅 비율별 배포 정책 예시
          - (90 : 10)
          - kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
          - (75 : 25)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - #kubectl delete vs recommendation -n tutorial
          - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
      - Client 브라우저 유형별 스마트 라우팅
        - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
          - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
        - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
        - (Browser 환경이 지원되지 않을 경우,)
          - curl -A Safari Externl-IP:8080
          - curl -A Firefox Externl-IP:8080
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - kubectl delete vs recommendation -n tutorial
  - <b>Lab. Istio - Timeout & Retry</b>
    - Lab에 필요한 모듈(Message Queue) 설치
      - kubectl get svc my-kafka -n kafka
      - 미설치시, 설치 링크 (https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629)
    - tutorial  네임스페이스에 Istio 기능 추가
      - kubectl label namespace tutorial istio-injection=enabled --overwrite
      - 네임스페이스가 없을 시, 생성 후 실행
    - Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
      - Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
        - Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입
          " @PrePersist
	          public void onPrePersist(){  
	          try {
	            Thread.currentThread().sleep((long) (800 + Math.random() * 220));
	          } catch (InterruptedException e) {
	             e.printStackTrace();
	          }
	        }"
        - Docker image Build & Push
        - tutorial 네임스페이스에 Order 서비스 배포 
        ```
          "kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: order
              namespace: tutorial
              labels:
                app: order
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: order
              template:
                metadata:
                  labels:
                    app: order
                spec:
                  containers:
                    - name: order
                      image: IMAGE_FULL_REPOSITORY_URL/order:v1
                      ports:
                        - containerPort: 8080
                      resources:
                        limits:
                          cpu: 500m
                        requests:
                          cpu: 200m
            EOF"
          ```
        - Order 서비스 생성
          - kubectl expose deploy order --port=8080 -n tutorial
        - Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시) 
          - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
          - nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가
            ```
            " - match:
               - uri:"
                prefix: /orders
              route:
            " - destination:
              host: order
              port:
              number: 8080
              timeout: 3s"
              ```
          - (변경 내용 적용)
          - kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial
        -  Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)
          ```
            "kubectl apply -f - <<EOF
              apiVersion: networking.istio.io/v1alpha3
              kind: VirtualService
              metadata:
                name: vs-order-network-rule
                namespace: tutorial
              spec:
                hosts:
                - order
                http:
                - route:
                  - destination:
                      host: order
                  timeout: 3s
            EOF"
            ```
        - 부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing 
          - kubectl run siege --image=apexacme/siege-nginx -n tutorial 
          - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
          - siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'
      - Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인
    - Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule 
      - Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포
      - Docker image Build & Push
      - tutorial 네임스페이스에 Delivery 서비스 배포  
        ```
        "kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: delivery
            namespace: tutorial
            labels:
              app: delivery
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: delivery
            template:
              metadata:
                labels:
                  app: delivery
              spec:
                containers:
                  - name: delivery
                    image: IMAGE_FULL_REPOSITORY_URL/delivery:v1
                    ports:
                      - containerPort: 8080
                    resources:
                      limits:
                        cpu: 500m
                      requests:
                        cpu: 200m
          EOF"
          ```
      - Delivery 서비스 생성
        - kubectl expose deploy delivery --port=8080 -n tutorial
      - Order 서비스에 Retry Rule 추가 적용
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: vs-order-network-rule
            namespace: tutorial
          spec:
            hosts:
            - order
            http:
            - route:
              - destination:
                  host: order
              timeout: 3s
              retries:
                attempts: 3
                perTryTimeout: 2s
                retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
          EOF"
          ```
      - Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
        - kubectl scale deploy delivery --replicas=0 -n tutorial
        - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
        - http http://order:8080/orders/ productId=1001 qty=5
          - httpie가 없을 시,
          - apt-get update
          - apt-get install httpie
        - http DELETE http://order:8080/orders/1 
      - Jaeger 접속(http://tracing svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기
        "< 검색조건 >
          Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*
          검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅"
  - <b>Lab. Istio - Circuit Breaker</b>
    - Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)
    - Namespace 생성 및 Istio 활성
      - kubectl create namespace istio-cb-ns
      - kubectl label namespace istio-cb-ns istio-injection=enabled
    - Istio Retry 디폴트 동작 확인  
      - 테스트 어플리케이션 배포
        - hello-server-1, hello-server-2 Pods, Service
        - hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함.
          ```
          "kubectl apply -f - << EOF
            apiVersion: v1
            kind: Pod
            metadata:
              name: hello-server-1
              namespace: istio-cb-ns
              labels:
                app: hello
            spec:
              containers:
                - name: hello-server-1
                image: docker.io/honester/hello-server:latest
                imagePullPolicy: IfNotPresent
                env:
                - name: VERSION
                  value: "v1"
                - name: LOG
                  value: "1" 
            ---
            apiVersion: v1
            kind: Pod
            metadata:
              name: hello-server-2
              namespace: istio-cb-ns
              labels:
                app: hello
            spec:
              containers:
                - name: hello-server-2
                image: docker.io/honester/hello-server:latest
                imagePullPolicy: IfNotPresent
                env:
                - name: VERSION
                  value: "v2"
                - name: LOG
                  value: "1"
                - name: RANDOM_ERROR
                  value: "0.2"
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: svc-hello
              namespace: istio-cb-ns
              labels:
                app: hello
            spec:
              selector:
                app: hello
              ports:
                - name: http
                protocol: TCP
                port: 8080
            EOF"
            ```
        - 클라이언트용 서비스(httpbin) 배포
          ```
          "kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: httpbin
              namespace: istio-cb-ns
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: httpbin
              template:
                metadata:
                  labels:
                    app: httpbin
                spec:
                  containers:
                  - name: httpbin
                    image: docker.io/honester/httpbin:latest
                    imagePullPolicy: IfNotPresent
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: httpbin
              namespace: istio-cb-ns
              labels:
                app: httpbin
            spec:
              selector:
                app: httpbin
              ports:
                - name: http
                port: 8000
                targetPort: 80
            EOF"
            ```
      - Retry 디폴트 동작 테스트
        - hello-server-2의 로그 모니터 걸기
          - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - 클라이언트에서 svc-hello 서비스 10번 호출하기
          - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
      - 결과 확인/분석
        "1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
        2) 핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)"
    - Circuit Breaker 설정
      - 대기 쓰레드수 기반 Circuit Breaker
        - 클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정 
        - (Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking)
        ``` 
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-httpbin
              namespace: istio-cb-ns
            spec:
              host: httpbin
              trafficPolicy:
                connectionPool:
                  http:
                    http1MaxPendingRequests: 1
                    maxRequestsPerConnection: 1
            EOF"
          ```
        - Circuit Breaker 동작 확인 
          - 부하테스트 툴(Siege) 설치 및  Load Testing 
            - kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns
            - kubectl exec -it siege -c siege -n istio-cb-ns -- /bin/bash
              - siege -c1 -t10S -v http://httpbin:8000/get  # 100% availability
              - siege -c2 -t10S -v http://httpbin:8000/get  # 87% availability
          - Kiali(Externl-IP:20001) 모니터링
      - 로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker 
        - Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정
          ```
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-hello-server
              namespace: istio-cb-ns
            spec:
              host: svc-hello
              trafficPolicy:
                outlierDetection:
                  interval: 1s
                  consecutiveErrors: 1
                  baseEjectionTime: 3m
                  maxEjectionPercent: 100
            EOF"
            ```
        - Circuit Breaker 동작 확인 
          - 클라이언트(httpbin Pod)에서 svc-hello 호출 
            - hello-server-2의 로그 모니터 걸기
              - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
            - 클라이언트에서 svc-hello 서비스 10번 호출하기
              - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
            - 결과 확인/분석
              "1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다. 
              2) 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인"
    - 동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
      - Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-delivery
            namespace: tutorial
          spec:
            host: delivery
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 30
                  maxRequestsPerConnection: 100
              outlierDetection:
                interval: 5s
                consecutiveErrors: 1
                baseEjectionTime: 5m
                maxEjectionPercent: 100
          EOF"
          ```
      - 설정 내용
        - 최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)
        - 5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)
        - 또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음
    - Clean-up
      - kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns
  - <b>Clear Istio </b>
    - kubectl delete ns tutorial istio-cb-ns istio-system





</details>
        
</p>
</details>

<hr />


### 마이크로소프트 Azure
<details>
<summary>Azure Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>


<details>
<summary><b>자주 사용되는 Azure Cloud 명령어</b></summary>

  - <b>구독(종량제) 설정</b>
    - ex) az account set --subscription "종량제2"
  - <b>Azure 클러스터 생성</b>
    - az aks create --resource-group user01_resource_group --name user01_cluster --node-count 2 --enable-addons monitoring --generate-ssh-keys
  - <b>Azure 클러스터 토큰 가져오기</b>
    - az aks get-credentials --resource-group (user01_resource_group) --name (user01-cluster)
  - <b>Azure 컨테이너 레지스트리 생성</b>
    - az acr create --resource-group (user01_resource_group) --name (user01) --sku Basic
  - <b>Azure 컨테이너 레지스트리 로그인</b>
    - az acr login --name (user01) 
  - <b>Azure 클러스터(AKS)에 레지스트리(ACR) 붙이기</b>
    - az aks update -n (user01_cluster) -g (user01_resource_group) --attach-acr (user01_registry)
  - <b>Azure 레지스트리(ACR)에 도커 이미지 푸시하기</b>
    - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/[이미지명]:latest .
  - <b>Azure 클러스터 삭제</b>
    - az aks delete --name MyManagedCluster --resource-group MyResourceGroup
  - <b>Azure 리소스그룹 삭제</b>
    - az group delete --name rsrcgroup
  - <b>Azure AKS 모니터링</b>
    - admin-user 서비스 계정 및 클러스터 롤 바인딩 생성
      ```
      "cat <<EOF | kubectl apply -f -
      ---
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: admin-user
        namespace: kube-system
      ---
      apiVersion: rbac.authorization.k8s.io/v1beta1
      kind: ClusterRoleBinding
      metadata:
        name: admin-user
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
      - kind: ServiceAccount
        name: admin-user
        namespace: kube-system
      EOF"
      ```
    - 인증 토큰 조회
      - kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
    - az aks browse --resource-group (resource-group-name) --name (cluster-name)
    - 복사된 토큰값 붙여넣기 및 로그인
    
</details>    
    
### Docker

<details>
<summary><b>Setup</b></summary>    </b>

- <b>관리자 권한으로 PowerShell 실행</b>
  - Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
- <b>리눅스설치 및 실행</b>
  - (설치전 확인 사항)
    - Windows 기능 켜기/끄기에서 'Linux용 Windows 하위시스템 활성화' 확인
    - 개발자 기능사용에서 '개발자 모드' 활성화 확인
  - Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
    - sudo vi /etc/apt/sources.list
    - :%s/archive.ubuntu.com/ftp.daumkakao.com/g
    - :wq!
    - sudo apt-get update
- <b>Linux에 JDK 설치</b>
  - (설치 명령)
  - sudo apt-get update
  - sudo apt install default-jdk
  - (bash에 환경변수 추가)
  -  cd ~
  - nano .bashrc
  - (맨아래로 이동)
  - (JAVA_HOME 설정 및 실행 Path 추가)
    "export JAVA_HOME=‘/usr/lib/jvm/java-11-openjdk-amd64
      export PATH=$PATH:$JAVA_HOME/bin:."
  - (수정사항 반영)
    - ctrl + x, y 입력, 종료
    - source ~/.bashrc
  - (설치 확인)
  - echo $JAVA_HOME
  - java -version
- <b>Windows에 도커 데몬 설치</b>
  - https://www.docker.com/products/docker-desktop
- <b>도커허브 계정생성</b>
  -  http://hub.docker.com 접속 후, Sign Up (회원가입)
- <b>리눅스에 도커 Client 설치</b>
  - sudo apt-get update
  - 비밀번호 입력창에 skadmin1234
  - sudo apt install apt-transport-https ca-certificates curl software-properties-common
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add 
  - sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
  - sudo apt update
  - sudo apt install docker-ce
  - #리눅스 설치시 생성한 사용자 명 입력
  - sudo usermod -aG docker skccadmin
- <b>도커 데몬과 도커 Client 연결 </b>
  - cd
  - nano .bashrc
  - 맨아래 줄에 아래 환경변수 추가
    - 방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력
    - export DOCKER_HOST=tcp://0.0.0.0:2375 
    - 저장 & 종료 : Ctrl + x, 입력 후, y 입력  후 엔터
  - source ~/.bashrc
  - 연결 확인
    - docker images
    - docker run --name nginx -d -p 80:80 nginx
    - docker images
</details> 

 <details>
<summary><b>Docker Hands-On</b></summary>
    
- <b>Lab. image</b>
  - 이미지 Pull
    - docker pull hello-world
    - docker images 
    - docker pull nginx
    - docker pull nginx:latest
    - docker pull docker.io/library/nginx:latest
    - docker pull nginx:1.16.1
    - docker images
  - 도커허브 (Docker Hub) 
    - http://hub.docker.com # 접속 후, nginx 검색 
  - 이미지 Tagging
    - docker image tag nginx my-nginx # Create 태그
  - 이미지 삭제
    - docker image rm my-nginx
    - docker image rm hello-world
    - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
- <b>Lab. container</b>
  - 컨테이너 생성
    - docker run hello-world # 컨테이너 만들기
    - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
    - docker run --name my-nginx -d -p 80:80 nginx
    - docker ps
  - 컨테이너 시작/종료
    - docker stop my-nginx
    - docker start my-nginx
  - 컨테이너 포트 노출
    - http://localhost 에서 nginx index.html 확인
    - docker container rm my-nginx
    - docker run --name my-nginx -d -p 8080:80 nginx
    - http://localhost:8080 에서 nginx index.html 확인
  - 컨테이너 접근
    - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
    - docker exec -i -t  my-nginx /bin/bash
      - apt-get update
      - apt-get install curl
      - curl localhost
      - exit
  - 컨테이너 삭제
    - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
    - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
- <b>Lab. Docker Build & Push</b>
  - Dockerfile로부터 이미지 생성
    - Dockerfile & 리소스 생성
      - mkdir Dockerfile
      - cd Dockerfile
      - nano index.html
        "Hi~ My name is Park Yong Joo.."
      - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
      - nano Dockerfile
        "FROM nginx
        COPY index.html /usr/share/nginx/html/"
      - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
    - 도커라이징 & Push
      - docker build -t (Docker-ID)/my-nginx:v1 . 
      - docker images
      - docker push (Docker-ID)/my-nginx:v1
        "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
    - http://hub.docker.com 에서 이미지 확인
    - Docker Hub 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 (Docker-ID)/my-nginx
    - Browser에서 실행 애플리케이션 확인
      - http://localhost:8080
- <b>Clear</b>
  - docker container rm $(docker ps -a -q)
    - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
    - docker container stop new-nginx
  - docker image rm -f $(docker images -q)

</details>  
  
### Kubernetes 

 <details>
<summary><b>Cloud Setup</b></summary>

  - <b>Cloud Shell 에서 Setup 확인 명령</b>
      - az aks get-credentials --resource-group My_Resource_Group --name My-cluster
      - kubectl config current-context
      
  - <b>Cloud Client Setup</b>
    - Kubectl 설치 (ubuntu 18.04)
      - sudo apt-get update && sudo apt-get install -y apt-transport-https
      - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
      - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
      - sudo apt-get update
      - sudo apt-get install -y kubectl
    - Azure-Cli 설치
      - curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
      - az login -u ~~ -p ~~
    - Local에 AKS(Azure Kubernetes Service) 클러스터 접속정보 설정
      - az aks get-credentials --resource-group [azure-resource-name] --name [azure-cluster-name]
      - kubectl config current-context
      - kubectl get all
    - Local에 ACR(Azure Container Registry) 접속정보 설정
      - az acr login --name [azure-registry-name]
    - Azure AKS와 ACR 연결 (4')
      - az aks update -n [azure-cluster-name] -g [azure-resource-Group-name] --attach-acr [azure-acr-name]

</details>      

<details>
<summary><b>Kubernetes Hands-on</b></summary>

- <b>Lab에 필요한 리소스 내려받기</b>
  - git clone https://github.com/event-storming/container-orchestration.git
  - cd container-orchestration
  - cd yaml
    
- <b>Lab. K8s Sample App 생성</b>
  - 어플리케이션 생성/ 확인
    - Docker hub에 올린 이미지를 통한 컨테이너 생성
      "kubectl create deploy my-nginx --image=apexacme/my-nginx:v1"
    - 클러스터 외부에 노출하기
      "kubectl expose deploy my-nginx --type=LoadBalancer --port=80"
  - 서비스 확인하기
    - kubectl get svc의 EXTERNAL-IP 복사
    - Browser에서 EXTERNAL-IP:80 접속
- <b>Lab. Pod & 기본명령</b>
  - kubectl get nodes
    - 쿠버네티스에 제대로 접속했는지 확인
    - 현 클러스터의 워크노드를 리스트업
    - 접속 결과 안나오는 경우
      - kubectl config current-context 명령으로 Cluster 접속 확인
  - 객체의 검색
    - kubectl get [object type]
    - kubectl get pods   # pods = pod = po
    - kubectl get deployments   # deploy
    - kubectl get services    # svc
    - kubectl get replicaset    # rs
  - 객체의 모니터링
    - watch kubectl get all
    - kubectl get pod -w
    - watch kubectl get pod
  - 객체의 유형
    - Service 
      - types
        - LoadBalancer
          - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
          - front-end 혹은 ingress (api gateway)
        - ClusterIP(default) / NodePort
          - 클러스터 내부 IP
          - 내부 마이크로 서비스
    - Deployment
      - ReplicaSet (하나이상 생성)
        - Pod (하나이상 생성)
          - Container (docker ) 하나이상.
    - Pod
    - ReplicaSet
    - Ingress
    - Secret
    - ConfigMap
    - ServiceAccount = sa
    - statefulset
    - daemonset
  - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
    - nano declarative-pod.yaml
      "apiVersion: v1
      kind: Pod
      metadata:
        name: declarative-pod
        labels:
          env: test
      spec:
        containers:
        - name: memory-demo-ctr
          image: nginx"
    - 저장 및 종료 (ctrl + X, Y, 엔터)
    - kubectl create -f declarative-pod.yaml
    - kubectl get pods
  - 원하는 Node 타입에 Pod 생성
    - #pwd 로 현 위치가 /container-orchestration/yaml/pod 인지 확인
    - kubectl create -f pod-with-nodeselector.yaml
    - kubectl get po -o wide
      - Pod가 찾는 노드가 없어 pending 상태
    - 노드에 라벨 추가
      - kubectl label nodes [your-node-name] disktype=ssd
      - kubectl get nodes --show-labels | grep ssd
    - kubectl get po -o wide
  - Pod 생성 전 초기화  
    - kubectl create -f pod-initialize.yaml
    - kubectl get po
    - #생성된 Pod 내로 접근
    - kubectl exec -it init-demo -- /bin/bash 
    - cd /usr/share/nginx/html
    - ls
  - 생성된 Pod 및 오브젝트 삭제
    - kubectl delete pod [pod명]
    - kubectl delete service,deploy --all
- <b>Lab. Label </b>
  - kubectl run nginx --image=nginx
  - kubectl get pods -l run=nginx
  - kubectl get pods --selector run=nginx
  - kubectl get pods --selector 'run in (nginx, test)'
- <b>Lab. ReplicaSet</b>
  - pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인
  - kubectl create -f replicaset.yaml
  - kubectl get all
  - #replica 개수 조정
    - kubectl scale replicaset/frontend --replicas=5
    - kubectl get po 
- <b>Lab. Deployment & 기본명령 </b>
  - 기본 nginx 서버의 배포
  - kubectl create deploy nginx --image=nginx
  - kubectl get deploy nginx
  - kubectl get replicaset -l app=nginx
  - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
  - kubectl describe po (검색한 pod name)
  - (pod 제거)
  - kubectl delete po --all   # 
  - (pod 를 제거해도 재생됨을 확인)
  - kubectl get po
  - (scale out)
  - kubectl scale deploy nginx --replicas=3
  - kubectl get po   # pod 개수가 3개로 늘어남을 확인
  - kubectl delete po --all   # pod 를 모두 지움
  - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
  - ( 제거하기 위해서는 deployment 를 제거해야만 함)
  - kubectl delete deploy nginx
- <b>Lab. Rollout & Back</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)
  - kubectl create -f nginx.yaml
  - (아래 명령으로 배포 주석 추가, Rollback시 필요) 
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
  - Set image 명령을 통한 이미지 Rollout  및 확인
  - kubectl set image deploy nginx-deployment nginx=nginx:1.9.1
  - kubectl rollout history deploy nginx-deployment
  - (배포주석 달기)
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is nginx:1.9.1'
  - kubectl describe po [해당 deployment 의 pod 중 하나의 이름]    # 내용의 image 부분이 1.9.1 인지 확인
  - (무정지 재배포 히스토리 확인)
  - kubectl rollout history deploy nginx-deployment
  - (다음과 같이 출력됨을 확인)
    "REVISION  CHANGE-CAUSE
    1         v1 is nginx:1.7.9
    2         v2 is nginx:1.9.1"
  - (롤백하기)
  - kubectl rollout undo deploy nginx-deployment
  - kubectl rollout undo deploy nginx-deployment --to-revision 5
- <b>Lab. Service</b>
  - Basic YAML
    "apiVersion: v1
      kind: Service
      metadata:
        name: my-service
      spec:
        selector:
          app: MyApp
        ports:
          - protocol: TCP
            port: 80
            targetPort: 8080"
  - kubectl delete service,deploy --all  # 기존 이력 삭제 
  - (다시 생성)
  - kubectl create deploy nginx --image=nginx
  - (서비스로 노출)
  -  kubectl expose deploy nginx --type="LoadBalancer" --port=80
  - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
  - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
- <b>Auto Scale-Out </b>
  - pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인
  - (모든 객체 지우기)
  - kubectl delete deploy,service,pod --all
  - (대상 서비스 배포 및 모니터링)
  - kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
    - NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함
      "resources:
            limits:
              cpu: 500m
            requests:
              cpu: 200m"
  - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
    - kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10
      "cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)"  
    - kubectl get hpa php-apache -o yaml
  - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
    - cat siege.yaml
    - kubectl create -f siege.yaml
    - kubectl exec -it siege -- /bin/bash
  - 로드 생성
    - siege -c30 -t30S -v http://php-apache
  - (오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)
    - metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인 
    - 디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인
    - cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음
- <b>Lab. Volume</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)
  - (emptyDir 마운트)
  - kubectl create -f volume-emptydir.yaml
  - (GitRepository를 볼륨으로 마운트)
  - kubectl create -f volume-gitrepo.yaml
  - (PersistentVolumeClaim 생성)
  - kubectl create -f volume-pvc.yaml
  - kubectl get pvc 
  - kubectl describe pvc azure-managed-disk
  - (생성된 PersistentVolueClaim으로 Pod 생성하기)
  - kubectl create -f pod-with-pvc.yaml
  - kubectl describe pod mypod
  - (포드 접속)
  - kubectl exec -it mypod -- /bin/bash
  - (마운트 및 사이즈 확인)
  - df -k
- <b>Lab. ConfigMap</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)
  - (컨피그 맵 생성)
  - kubectl create configmap hello-cm --from-literal=language=java
  - kubectl get cm
  - kubectl get cm hello-cm -o yaml
  - (도커라이징 & ACR Push)
    - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/cm-sandbox:v1 .
  - (인증오류 발생 시, ACR 로그인)
    - az acr login --name (Azure Container Registry 명) --expose-token
    - Token Expose관련 오류 > expose-token 생략
  - 클라우드에서 배포 이미지 확인
  - nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)
  - (배포 및 서비스 생성)
    - kubectl create -f cm-deployment.yaml
    - kubectl create -f cm-service.yaml
  - (서비스 확인)
    - Service의 External-IP 접속
- <b>Lab. Secret</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)
  - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
- <b>Lab. Liveness & Readiness Probe</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)
  - (Liveness Command Probe 실습)
    - kubectl create -f exec-liveness.yaml 
    - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-exec
  - (Liveness HTTP Probe 실습)
    - kubectl create -f http-liveness.yaml
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-http
  - (Liveness 와 readiness probe 동시 적용 실습)
    - kubectl create -f tcp-liveness-readiness.yaml
    - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
    - kubectl describe po goproxy
</details>

<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>
   
- <b>Lab. Ingress</b>
  - Helm 명령으로 설치 여부 확인
  - Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
    - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
    - (설치 중, sudo를 위한 비밀번호 입력) 
    - kubectl --namespace kube-system create sa tiller 
    - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
    - helm init --service-account tiller
  - Helm으로 Ingress Controller 설치
    - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    - helm repo update
    - kubectl create namespace ingress-basic
    - helm version으로 버전확인
    - (helm version 2.x 일때) 
    - helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic
    - (helm version 3.x 일때) 
    - helm install  nginx-ingress stable/nginx-ingress --namespace=ingress-basic
    - (설치확인)
      - kubectl get all --namespace=ingress-basic
      - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
  - Ingress 대상 서비스(BLUE, GREEN) 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-blue-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-blue-deployment.yaml  
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-green-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-green-deployment.yaml 
    - (서비스 생성 확인)
      - kubectl get deploy,service -n ingress-basic
  - Ingress Routing Rule 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)
    - kubectl create -f path-based-ingress.yaml
    - kubectl get ingress -n ingress-basic
  - Ingress 테스트
    - 인그레이스 리소스 삭제
    - kubectl delete namespace ingress-basic
- <b>Azure AKS 모니터링</b>
  - admin-user 서비스 계정 및 클러스터 롤 바인딩 생성
    ```
    "cat <<EOF | kubectl apply -f -
      ---
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: admin-user
        namespace: kube-system
      ---
      apiVersion: rbac.authorization.k8s.io/v1beta1
      kind: ClusterRoleBinding
      metadata:
        name: admin-user
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
      - kind: ServiceAccount
        name: admin-user
        namespace: kube-system
      EOF"
      ```
  - 인증 토큰 조회
    - kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
  - az aks browse --resource-group (resource-group-name) --name (cluster-name)
  - 복사된 토큰값 붙여넣기 및 로그인

 </details>
         
 <details>
<summary><b>Real MSA Application Deployment</b></summary>

  - <b>사전작업</b>
    - az acr login --name [acr-repository-name] --expose-token
    - cd  ~
    - mkdir MSA-Sample
    - cd MSA-Sample
    
  - <b>마이크로서비스 배포</b>
    - 상품(Product) 서비스 
      "git clone https://github.com/event-storming/reqres_products.git
      cd reqres_products
      
      mvn package -Dmaven.test.skip=true
      
      az acr build --registry (myregistry) --image (myregistry).azurecr.io/products:latest .
      
      kubectl create deploy products --image=(myregistry).azurecr.io/products:latest
      kubectl expose deploy products --type="ClusterIP" --port=8080
      
      cd .."
    - 여러 서비스를 편하게 배포하기 위해 Container Registry를 환경변수로 설정
      - export CRNAME=(myregistry)
      - export ACR=${CRNAME}.azurecr.io
    - 주문(Order) 서비스 
      "git clone https://github.com/event-storming/reqres_orders.git
      cd reqres_orders
      export IMAGENAME=orders

      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080

      cd .."
    - 배송(Delivery) 서비스
      "git clone https://github.com/event-storming/reqres_delivery.git
      cd reqres_delivery
      export IMAGENAME=delivery

      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080

      cd .."
    - 인증(Oauth) 서비스 
      "git clone https://github.com/event-storming/oauth.git
      cd oauth
      export IMAGENAME=oauth
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 게이트웨이(Gateway) 서비스
      "git clone https://github.com/event-storming/gateway.git
      cd gateway
      export IMAGENAME=gateway
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
    - 프론트-엔드(UI) 서비스 빌드를 위한 npm 설치 (Azure Cloud에서 실행시 Skip)
      "sudo apt-get update
      sudo apt install build-essential
      curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
      sudo apt install nodejs
      "
    - 프론트-엔드(UI) 서비스: 배포 사전 작업
      "git clone https://github.com/event-storming/ui.git
      cd ui
      export IMAGENAME=ui
      
      npm install
      npm run build
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      
      _GATEWAY_IP=$(kubectl get -o jsonpath="{.status.loadBalancer.ingress[0].ip}" svc gateway --ignore-not-found)
      echo ${_GATEWAY_IP}
      "
    - 프론트-엔드(UI) 서비스:  배포 및 서비스 생성
      ```
      "cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${IMAGENAME}
        labels:
          app: ${IMAGENAME}
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ${IMAGENAME}
        template:
          metadata:
            labels:
              app: ${IMAGENAME}
          spec:
            containers:
              - name: ${IMAGENAME}
                image: ${ACR}/${IMAGENAME}:latest
                ports:
                  - containerPort: 8080
                env:
                  - name: VUE_APP_API_HOST
                    value: http://${_GATEWAY_IP}:8080
      EOF
      
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
      ```
  - <b>서비스 확인</b>
    - kubectl get svc ui
    - 브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080
    
 </details>
         
 <details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>

  - <b>Lab. Istio Install</b>
    - Istio 설치
    - curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -
      "(istio v1.7.1은 Kubernetes 1.16이상에서만 동작)"
    - cd istio-1.7.1
    - export PATH=$PWD/bin:$PATH
    - istioctl install --set profile=demo
      "note : there are other profiles for production or performance testing."
    - Istio 모니터링 툴(Telemetry Applications) 설치
      - kubectl apply -f samples/addons
      - 모니터링(Tracing & Monitoring) 툴 설정
        - Monitoring Server - Kiali
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc kiali -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
        - Tracing Server - Jaeger
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc tracing -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80
    - 설치확인
      - kubectl get all -n istio-system
  - <b>How to enable Istio</b>
    - 1. Whenever deploying to Cluster, Using pre-processing command 'Istio kube-inject'
      - kubectl apply -f <(istioctl kube-inject -f Deployment.yml) -n istio-test-ns
    - 2. Using Istio-enabled Namespace.  
      - e.g. kubectl label namespace istio-test-ns istio-injection=enabled
  - <b>Lab. Istio Tutorial 셋업</b>
    - Git repository에서 Tutorial 리소스 가져오기
      - cd ~
      - mkdir git
      - cd git
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - 네임스페이스 생성
      - kubectl create namespace tutorial
    - Customer Service 배포
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
        - kubectl describe pod (Customer Pod) -n tutorial 로 생성확인
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
    - Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
      - cat customer/kubernetes/Gateway.yml 
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
      - (Istio-IngressGateway를 통한 Customer 서비스 확인)
        - kubectl get service/istio-ingressgateway -n istio-system
        - 해당 EXTERNAL-IP가 Istio Gateway 주소
        - Customer 서비스 호출 : 
          "http://(istio-ingressgateway IP)/customer"
    - Preference, Recommendation-v1 Service 배포      
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
  - <b>Lab. Istio - Traffic Routing</b>
    - Simple Routing
      - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
      - (recommendation 서비스 추가 배포: v2)
        - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
      - 서비스 호출
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
        - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
      - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
      - (Recommendation v.2 서비스 Scale Out)
      - (서비스의 v2 의 replica 를 2로 설정)
        - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
        - kubectl get po -n tutorial

      - Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출
      - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
    - Advanced Routing
      - 정책(VirtualService, DestinationRule) 설정
        - (현, 정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
        - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
          - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
        - (설정정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (서비스 확인)
          - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
          - Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링
      - 가중치 기반 스마트 라우팅 (Canary Deployment)
        - (recommendation 서비스 v1의 가중치를 100으로 변경)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
        - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
          - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - Canary 라우팅 비율별 배포 정책 예시
          - (90 : 10)
          - kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
          - (75 : 25)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - #kubectl delete vs recommendation -n tutorial
          - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
      - Client 브라우저 유형별 스마트 라우팅
        - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
          - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
        - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
        - (Browser 환경이 지원되지 않을 경우,)
          - curl -A Safari Externl-IP:8080
          - curl -A Firefox Externl-IP:8080
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - kubectl delete vs recommendation -n tutorial
          
  - <b>Lab. Istio - Timeout & Retry</b>
    - Lab에 필요한 모듈(Message Queue) 설치
      - kubectl get svc my-kafka -n kafka
      - 미설치시, 설치 링크 (https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629)
    - tutorial  네임스페이스에 Istio 기능 추가
      - kubectl label namespace tutorial istio-injection=enabled --overwrite
      - 네임스페이스가 없을 시, 생성 후 실행
    - Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
      - Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
        - Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입
          ```
          "@PrePersist
	          public void onPrePersist(){  
            try {
                Thread.currentThread().sleep((long) (800 + Math.random() * 220));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
          }"
          ```
        - Docker image Build & Push
        - tutorial 네임스페이스에 Order 서비스 배포  
          ```
          "kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: order
              namespace: tutorial
              labels:
                app: order
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: order
              template:
                metadata:
                  labels:
                    app: order
                spec:
                  containers:
                    - name: order
                      image: IMAGE_FULL_REPOSITORY_URL/order:v2
                      ports:
                        - containerPort: 8080
                      resources:
                        limits:
                          cpu: 500m
                        requests:
                          cpu: 200m
            EOF"
            ```
        - Order 서비스 생성
          - kubectl expose deploy order --port=8080 -n tutorial
        - Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시) 
          - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
          - nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가
            ```
            "- match:
                - uri:
                    prefix: /orders
                route:
                - destination:
                    host: order
                    port:
                      number: 8080
                timeout: 3s"
              ```
          - (변경 내용 적용)
          - kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial
        - Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)
          ```
          "kubectl apply -f - <<EOF
              apiVersion: networking.istio.io/v1alpha3
              kind: VirtualService
              metadata:
                name: vs-order-network-rule
                namespace: tutorial
              spec:
                hosts:
                - order
                http:
                - route:
                  - destination:
                      host: order
                  timeout: 3s
              EOF"
              ```
        - 부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing 
          - kubectl run siege --image=apexacme/siege-nginx -n tutorial 
          - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
          - siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'
      - Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인
    - Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule 
      - Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포
      - Docker image Build & Push
      - tutorial 네임스페이스에 Delivery 서비스 배포  
        ```
        "kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: delivery
            namespace: tutorial
            labels:
              app: delivery
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: delivery
            template:
              metadata:
                labels:
                  app: delivery
              spec:
                containers:
                  - name: delivery
                    image: IMAGE_FULL_REPOSITORY_URL/delivery:v1
                    ports:
                      - containerPort: 8080
                    resources:
                      limits:
                        cpu: 500m
                      requests:
                        cpu: 200m
          EOF"
          ```
      - Delivery 서비스 생성
        - kubectl expose deploy delivery --port=8080 -n tutorial
      - Order 서비스에 Retry Rule 추가 적용
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: vs-order-network-rule
            namespace: tutorial
          spec:
            hosts:
            - order
            http:
            - route:
              - destination:
                  host: order
              timeout: 3s
              retries:
                attempts: 3
                perTryTimeout: 2s
                retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
          EOF"
          ```
      - Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
        - kubectl scale deploy delivery --replicas=0 -n tutorial
        - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
        - http http://order:8080/orders/ productId=1001 qty=5
          - httpie가 없을 시,
          - apt-get update
          - apt-get install httpie
        - http DELETE http://order:8080/orders/1 
      - Jaeger 접속(http://tracing svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기
        "< 검색조건 >
          Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*
          검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅"
  - <b>Lab. Istio - Circuit Breaker</b>
    - Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)
    - Namespace 생성 및 Istio 활성
      - kubectl create namespace istio-cb-ns
      - kubectl label namespace istio-cb-ns istio-injection=enabled
    - Istio Retry 디폴트 동작 확인  
      - 테스트 어플리케이션 배포
        - hello-server-1, hello-server-2 Pods, Service
        - hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함
          ```
          "kubectl apply -f - <<EOF
              apiVersion: v1
              kind: Pod
              metadata:
                name: hello-server-1
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                containers:
                - name: hello-server-1
                  image: docker.io/honester/hello-server:latest
                  imagePullPolicy: IfNotPresent
                  env:
                  - name: VERSION
                    value: "v1"
                  - name: LOG
                    value: "1"
              ---
              apiVersion: v1
              kind: Pod
              metadata:
                name: hello-server-2
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                containers:
                - name: hello-server-2
                  image: docker.io/honester/hello-server:latest
                  imagePullPolicy: IfNotPresent
                  env:
                  - name: VERSION
                    value: "v2"
                  - name: LOG
                    value: "1"
                  - name: RANDOM_ERROR
                    value: "0.2"
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: svc-hello
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                selector:
                  app: hello
                ports:
                - name: http
                  protocol: TCP
                  port: 8080
              EOF"
              ```
        - 클라이언트용 서비스(httpbin) 배포
          ```
          "kubectl apply -f - <<EOF
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: httpbin
                namespace: istio-cb-ns
              spec:
                replicas: 1
                selector:
                  matchLabels:
                    app: httpbin
                template:
                  metadata:
                    labels:
                      app: httpbin
                  spec:
                    containers:
                    - name: httpbin
                      image: docker.io/honester/httpbin:latest
                      imagePullPolicy: IfNotPresent
                      ports:
                      - containerPort: 80
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: httpbin
                namespace: istio-cb-ns
                labels:
                  app: httpbin
              spec:
                selector:
                  app: httpbin
                ports:
                - name: http
                  port: 8000
                  targetPort: 80
              EOF"
              ```
      - Retry 디폴트 동작 테스트
        - hello-server-2의 로그 모니터 걸기
          - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - 클라이언트에서 svc-hello 서비스 10번 호출하기
          - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
      - 결과 확인/분석
        "1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
          2) 핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)"
    - Circuit Breaker 설정
      - 대기 쓰레드수 기반 Circuit Breaker
        - 클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정 
        - (Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking) 
          ```
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-httpbin
              namespace: istio-cb-ns
            spec:
              host: httpbin
              trafficPolicy:
                connectionPool:
                  http:
                    http1MaxPendingRequests: 1
                    maxRequestsPerConnection: 1
            EOF"
            ```
        - Circuit Breaker 동작 확인 
          - 부하테스트 툴(Siege) 설치 및  Load Testing 
            - kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns
            - kubectl exec -it siege -c siege -n istio-cb-ns -- /bin/bash
              - siege -c1 -t10S -v http://httpbin:8000/get  # 100% availability
              - siege -c2 -t10S -v http://httpbin:8000/get  # 87% availability
          - Kiali(Externl-IP:20001) 모니터링
      - 로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker 
        - Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정
          ```
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-hello-server
              namespace: istio-cb-ns
            spec:
              host: svc-hello
              trafficPolicy:
                outlierDetection:
                  interval: 1s
                  consecutiveErrors: 1
                  baseEjectionTime: 3m
                  maxEjectionPercent: 100
            EOF"
            ```
        - Circuit Breaker 동작 확인 
          - 클라이언트(httpbin Pod)에서 svc-hello 호출 
            - hello-server-2의 로그 모니터 걸기
              - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
            - 클라이언트에서 svc-hello 서비스 10번 호출하기
              - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
            - 결과 확인/분석
              "1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다. 
                2) 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인"
    - 동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
      - Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-delivery
            namespace: tutorial
          spec:
            host: delivery
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 1
                  maxRequestsPerConnection: 1
              outlierDetection:
                interval: 5s
                consecutiveErrors: 1
                baseEjectionTime: 5m
                maxEjectionPercent: 100
          EOF"
          ```
      - 설정 내용
        - 최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)
        - 5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)
        - 또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음
    - Clean-up
      - kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns
  - <b>Clear Istio </b>
    - kubectl delete ns tutorial istio-cb-ns istio-system
    
 </details>
         
 <details>
<summary><b>Backup</b></summary>

  - <b>Container로부터 이미지 생성</b>
    - 이미지 생성
      - docker run --name my-nginx -d -p 80:80 nginx
      - docker exec -it my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - cd /usr/share/nginx/html
        - echo 'Hello my name is PYJ.' >> index.html
        - exit
      - docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성
      - docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인
      - docker commit -a "apex@naver.com" -m "update nginx" my-nginx my-nginx:1.0 
      - docker images
      - docker stop my-nginx
      - docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0
      - http://localhost 확인
      - docker stop my-nginx2
      
    - 이미지 푸시
      - docker tag my-nginx:1.0 apexacme/my-nginx:1.0
      - docker images
      - docker push apexacme/my-nginx:1.0
      - http://hub.docker.com 에서 이미지 확인
    - 도커허브 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0
  - <b>샘플 자바 애플리케이션 패키징과 배포 </b>
    - (pwd 로 현 위치가 /container-orchestration/ 인지 확인)
    - git clone https://github.com/event-storming/monolith.git
    - cd monolith/
    - ls
    - (skip) mvn spring-boot:run #Maven으로 App. 실행 
    - mvn package -B -Dmaven.test.skip=true
    - (skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행
    - cat Dockerfile # 도커파일 내용 확인
    - (도커라이징)
      - docker build -t (Azure container registry명).azurecr.io/monolith:v1 .     
        - #주의1 : 명령  맨끝에 " ." 빼먹으면 안됨.   Dockerfile 의 위치인
        - #주의2 : project id 부분을 자신의 GCP project id 로 변경!!
        - #주의3 : 현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함
      - docker images
      - (skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행
      - docker push (azure container registry명).azurecr.io/monolith:v1
    - kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1
    - kubectl get po -l app=monolith
    - kubectl expose deploy monolith --type="LoadBalancer" --port=8080
    - kubectl get svc -w
    - 자바 애플리케이션 접속
      - http://(Service_Extern-IP):8080
  - <b>Lab. Circuit Breaker function</b>
    - Istio가 활성화된 네임스페이스 생성 
      - kubectl create namespace istio-cb-ns
      - kubectl label namespace istio-cb-ns istio-injection=enabled
    - [CB 유스케이스] #1. Connection Max & Pending 수에 따른 Circuit Breaker
      - 테스트 어플리케이션 배포 (Deployment, Service)
        ```
        "kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: httpbin
            namespace: istio-cb-ns
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: httpbin
            template:
              metadata:
                labels:
                  app: httpbin
              spec:
                containers:
                - name: httpbin
                  image: docker.io/honester/httpbin:latest
                  imagePullPolicy: IfNotPresent
                  ports:
                  - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: httpbin
            namespace: istio-cb-ns
            labels:
              app: httpbin
          spec:
            selector:
              app: httpbin
            ports:
            - name: http
              port: 8000
              targetPort: 80
          EOF"
          ```
      - 로드 테스트 툴(siege) 배포
       ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: siege
            namespace: istio-cb-ns
          spec:
            containers:
            - name: siege
              image: apexacme/siege-nginx
          EOF"
          ```
      - siege를 통한 서비스(httpbin) 부하 생성
        - kubectl exec -it siege --container siege -n istio-cb-ns -- /bin/bash
        - siege -c1 -t10S -v http://httpbin:8000/get
        - siege -c1 -t10S -v http://httpbin.istio-cb-ns:8000/get
        - siege -c1 -t10S -v http://httpbin.istio-cb-ns.svc.cluster.local:8000/get
        - 서비스 모니터링 (Kiali) : EXTERNAL-IP:20001 (admin/admin)
      - DestinationRule 를 생성하여 CB가 발생할 수 있도록 Connection pool 설정 
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-httpbin
            namespace: istio-cb-ns

          spec:
            host: httpbin
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 1
                  maxRequestsPerConnection: 1
          EOF"
          ```
        - http1MaxPendingRequests=1 : Queue에서 Connection pool 에 연결을 기다리는 request 수를 1개로 제한
        - maxRequestsPerConnection=1 : keep alive 기능 disable 
      - siege를 통한 서비스(httpbin) 부하 재생성 및 CB 확인
        - siege -c1 -t10S -v http://httpbin:8000/get  # 100% Availability
        - siege -c2 -t10S -v http://httpbin:8000/get  # 87% availability
          - Envoy will return HTTP 503. It is the responsibility of the application to implement any fallback logic that is needed to handle the HTTP 503 error code from an upstream service. (https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html) 
        - 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)
      - Circuit Breaker 제거 후, 동일 로드 생성 후, Availability 100% 확인
        - kubectl delete dr/dr-httpbin -n istio-cb-ns
        - siege -c2 -t10S -v http://httpbin:8000/get  # 100% availability
      - Clean-up
        - kubectl delete deployment.apps/httpbin service/httpbin -n istio-cb-ns
    - [CB 유스케이스] #2. Load balancing pool의 인스턴스 상태에 기반한 Circuit Breaker
      - 테스트 어플리케이션 배포 (hello-server-1, hello-server-2 Pods, Service)
      - (hello-server:latest 이미지는 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함)
        ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: hello-server-1
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            containers:
            - name: hello-server-1
              image: docker.io/honester/hello-server:latest
              imagePullPolicy: IfNotPresent
              env:
              - name: VERSION
                value: "v1"
              - name: LOG
                value: "1"
          ---
          apiVersion: v1
          kind: Pod
          metadata:
            name: hello-server-2
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            containers:
            - name: hello-server-2
              image: docker.io/honester/hello-server:latest
              imagePullPolicy: IfNotPresent
              env:
              - name: VERSION
                value: "v2"
              - name: LOG
                value: "1"
              - name: RANDOM_ERROR
                value: "0.2"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: svc-hello
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            selector:
              app: hello
            ports:
            - name: http
              protocol: TCP
              port: 8080
          EOF"
          ```
      - 클라이언트용 Pod 설치
        ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: httpbin
            namespace: istio-cb-ns
            labels:
              app: httpbin
          spec:
            containers:
            - name: httpbin
              image: docker.io/honester/httpbin:latest
              imagePullPolicy: IfNotPresent
          EOF"
          ```
      - 클라이언트(httpbin Pod)에서 svc-hello 호출(default, Round-Robin)
        - (hello-server-2의 로그 모니터링)
        - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - (클라이언트에서 svc-hello 서비스 10번 호출하기)
        - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
      - 5XX 오류에 대해 해당 서비스 차단 및 Thread 부하에 따른 DestinationRule 생성
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-hello
            namespace: istio-cb-ns
          spec:
            host: svc-hello
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 5
                  maxRequestsPerConnection: 10
              outlierDetection:
                interval: 1s
                consecutiveErrors: 1
                baseEjectionTime: 3m
                maxEjectionPercent: 100
          EOF

          설명 : 1초 주기로 이상징후를 체크하며, 1번이라도 실패한 서비스는 3분동안 라우팅 대상에서 제외된다. 또한 모든 대상 서비스 인스턴스가 방출(제외)될 수 있다."
          ```
      - 클라이언트(httpbin Pod)에서 svc-hello 호출 및 CB 확인
        - (hello-server-2의 로그 모니터링)
        - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - (클라이언트에서 svc-hello 서비스 10번 호출하기)
        - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
        - 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)
      - 배송(delivery) 서비스에 Circuit Breaker 설치
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-delivery
            namespace: cna-shop
          spec:
            host: delivery
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 5
                  maxRequestsPerConnection: 10
              outlierDetection:
                interval: 1s
                consecutiveErrors: 1
                baseEjectionTime: 3m
                maxEjectionPercent: 100
          EOF"
          ```
     - Clean-up
      - kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns

  - <b>Lab. Istio Egress</b>
    - 외부 도메인을 호출하는 v3 버전을 배포
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
    - v3에서 날짜정보가 추가로 출력됨을 확인
    - Istio 트래픽을 등록된 것만 허용하도록 변경
      - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인
    - 트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
      - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial
      - kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - 화면에 Error Log 출력 : “customer => Error: 503 - preference => Error: 500”
    - 외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
      - kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력
    - (테스트 후, 설정 복구)
    - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g' | kubectl replace -n istio-system -f -

</details>

</p>
</details>
<hr />


### 아마존 AWS
<details>
<summary>AWS Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>

<details>
<summary><b>자주 사용되는 AWS Cloud 명령어</b></summary>

  - <b>Cloud Configuration</b>
    - aws configure
    
  - <b>AWS 클러스터 생성</b>
    - eksctl create cluster --name (Cluster-Name) --version 1.17 --nodegroup-name standard-workers --node-type t3.medium --nodes 3 --nodes-min 1 --nodes-max 3
  - <b>AWS 클러스터 토큰 가져오기</b>
    - aws eks --region (Region-Code) update-kubeconfig --name (Cluster-Name)
  - <b>AWS 컨테이너 레지스트리에 이미지 리파지토리 생성</b>
    - aws ecr create-repository --repository-name (Image-Repository-Name) --image-scanning-configuration scanOnPush=true --region (Region-Code)
  - <b>AWS 컨테이너 레지스트리 로그인</b>
    - aws ecr get-login-password --region (Region-Code) | docker login --username AWS --password-stdin (Account-Id).dkr.ecr.(Region-Code).amazonaws.com
    - 오류(unknown flag: --password-stdin) 발생 시,
      - docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/
  - <b>AWS 레지스트리에 도커 이미지 푸시하기</b>
    - aws ecr create-repository --repository-name (IMAGE_NAME) --region ap-northeast-2
    - docker push 283210891307.dkr.ecr.ap-northeast-2.amazonaws.com/(IMAGE_NAME):latest
  - <b>AWS 클러스터 삭제</b>
    - eksctl delete cluster --name (PROD_CLUSTER)
  - <b>AWS EKS 모니터링</b>
    - Metric-Server 설치
      - kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml
    - Kubernetes DashBoard 설치
      - kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml
    - eks-admin 서비스 계정 및 클러스터 롤 바인딩 생성
      ```
      "cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: eks-admin
          namespace: kube-system
        ---
        apiVersion: rbac.authorization.k8s.io/v1beta1
        kind: ClusterRoleBinding
        metadata:
          name: eks-admin
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: cluster-admin
        subjects:
        - kind: ServiceAccount
          name: eks-admin
          namespace: kube-system
        EOF"
        ```
    - 인증 토큰 조회
      - kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep eks-admin | awk '{print $1}')
    - Proxy 설정 및 DashBoard 연결
      - kubectl proxy
      - http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login
      - 복사한 토큰 정보로 로그인
</details>    
    
### Docker

<details>
<summary><b>Setup</b></summary>

- <b>관리자 권한으로 PowerShell 실행</b>
  - Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux      
- <b>리눅스설치 및 실행</b>
  - (설치전 확인 사항)
    - Windows 기능 켜기/끄기에서 'Linux용 Windows 하위시스템 활성화' 확인
    - 개발자 기능사용에서 '개발자 모드' 활성화 확인
  - Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
    - sudo vi /etc/apt/sources.list
    - :%s/archive.ubuntu.com/ftp.daumkakao.com/g
    - :wq!
    - sudo apt-get update
    
- <b>Linux에 JDK 설치</b>
  - (설치 명령)
  
  - sudo apt-get update
  - sudo apt install default-jdk
  - (bash에 환경변수 추가)
  -  cd ~
  - nano .bashrc
  - (맨아래로 이동)
  - (JAVA_HOME 설정 및 실행 Path 추가)
    "export JAVA_HOME='/usr/lib/jvm/java-11-openjdk-amd64'
      export PATH=$PATH:$JAVA_HOME/bin:."
  - (수정사항 반영)
    - ctrl + x, y 입력, 종료 
    - source ~/.bashrc
  - (설치 확인)
  - echo $JAVA_HOME
  - java -version
- <b>Windows에 도커 데몬 설치</b>
  - https://www.docker.com/products/docker-desktop
- <b>도커허브 계정생성</b>
  -  http://hub.docker.com 접속 후, Sign Up (회원가입)
- <b>리눅스에 도커 Client 설치</b>
  - sudo apt-get update
  - 비밀번호 입력창에 skadmin1234
  - sudo apt install apt-transport-https ca-certificates curl software-properties-common
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add 
  - sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
  - sudo apt update
  - sudo apt install docker-ce
  - #리눅스 설치시 생성한 사용자 명 입력
  - sudo usermod -aG docker skccadmin
- <b>도커 데몬과 도커 Client 연결 </b>
  - cd
  - nano .bashrc
  - 맨아래 줄에 아래 환경변수 추가
    - 방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력
    - export DOCKER_HOST=tcp://0.0.0.0:2375 
    - 저장 & 종료 : Ctrl + x, 입력 후, y 입력  후 엔터
  - source ~/.bashrc
  - 연결 확인
    - docker images
    - docker run --name nginx -d -p 80:80 nginx
    - docker images
</details>

<details>
<summary><b>Docker Hands-on</b></summary>   </b>
 
- <b>Lab. image</b>

  - 이미지 Pull
    - docker pull hello-world
    - docker images 
    - docker pull nginx
    - docker pull nginx:latest
    - docker pull docker.io/library/nginx:latest
    - docker pull nginx:1.16.1
    - docker images
    
  - 도커허브 (Docker Hub) 
    - http://hub.docker.com # 접속 후, nginx 검색 
  - 이미지 Tagging
    - docker image tag nginx my-nginx # Create 태그
  - 이미지 삭제
    - docker image rm my-nginx
    - docker image rm hello-world
    - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
- <b>Lab. container</b>
  - 컨테이너 생성
    - docker run hello-world # 컨테이너 만들기
    - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
    - docker run --name my-nginx -d -p 80:80 nginx
    - docker ps
  - 컨테이너 시작/종료
    - docker stop my-nginx
    - docker start my-nginx
  - 컨테이너 포트 노출
    - http://localhost 에서 nginx index.html 확인
    - docker container rm my-nginx
    - docker run --name my-nginx -d -p 8080:80 nginx
    - http://localhost:8080 에서 nginx index.html 확인
  - 컨테이너 접근
    - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
    - docker exec -i -t  my-nginx /bin/bash
      - apt-get update
      - apt-get install curl
      - curl localhost
      - exit
  - 컨테이너 삭제
    - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
    - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
- <b>Lab. Docker Build & Push</b>
  - Dockerfile로부터 이미지 생성
    - Dockerfile & 리소스 생성
      - mkdir Dockerfile
      - cd Dockerfile
      - nano index.html
        "Hi~ My name is Park Yong Joo.."
      - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
      - nano Dockerfile
        "FROM nginx
        COPY index.html /usr/share/nginx/html/"
      - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
    - 도커라이징 & Push
      - docker build -t Docker-ID/my-nginx:v1 . 
      - docker images
      - docker push Docker-ID/my-nginx:v1
        "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
    - http://hub.docker.com 에서 이미지 확인
    - Docker Hub 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 Docker-ID/my-nginx:v1
    - Browser에서 실행 애플리케이션 확인
      - http://localhost:8080
- <b>Clear</b>
  - docker container rm $(docker ps -a -q)
    - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
    - docker container stop new-nginx
  - docker image rm -f $(docker images -q)
</details>

### Kubernetes   
    
<details>
<summary><b>Cloud Client Setup</b></summary>
     
- <b>Kubectl 설치 (ubuntu 18.04)</b>
  - sudo apt-get update && sudo apt-get install -y apt-transport-https
  - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
  - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
  - sudo apt-get update
  - sudo apt-get install -y kubectl
  
- <b>AWS-Cli v2 설치</b>
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip awscliv2.zip
  - (unzip이 없을 경우, 설치)
    - sudo apt-get install unzip
  - sudo ./aws/install
- <b>AWS Configure</b>
  - (AWS 관리콘솔)
  - 1. 부여받은 교육 계정으로  AWS 콘솔 접속
  - 2. IAM 서비스 접속
  - 3. 왼쪽 메뉴에서 '엑세스 관리' > '사용자' 클릭
  - 4. 나의 계정정보 클릭
  - 5. 메인화면에서 '보안자격증명' 클릭
  - 6. '액세스 키 만들기' 클릭
  - 7. Access Key ID와 Secret Access key를 복사
  - (클라이언트 Tool)
  - aws configure 입력
  - 관리콘솔에 복사한 Access Key ID와 Secret Access key 입력
  - region 정보에 ap-northeast-2 입력
  - default output format에 json 입력
- <b>EKS Client (eksctl) 설치</b>
  - curl --location "https://github.com/weaveworks/eksctl/releases/download/latest_release/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
  - sudo mv /tmp/eksctl /usr/local/bin
- <b>Amazon EKS 생성</b>
  - eksctl create cluster --name user15-sk-Cluster --version 1.15 --nodegroup-name standard-workers --node-type t3.medium --nodes 2 --nodes-min 1 --nodes-max 3
- <b>Local에 EKS 클러스터 접속정보 설정</b>
  - aws eks --region eu-west-1 update-kubeconfig --name admin00-Cluster
  - kubectl config current-context
  - kubectl get all
- <b>Local에 ECR(Elastic Container Registry) 인증 및 토큰 설정</b>
  - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com
  - 오류(unknown flag: --password-stdin) 발생 시,
    - docker login --username AWS -p $(aws ecr get-login-password --region ca-central-1) 052937454741.dkr.ecr.ca-central-1.amazonaws.com/
</details>

<details>
<summary><b>Kubernetes Hands-on</b></summary>

- <b>Lab에 필요한 리소스 내려받기</b>
  - git clone https://github.com/event-storming/container-orchestration.git
  - cd container-orchestration
  - cd yaml_aws      
  
- <b>Lab. K8s Sample App 생성</b>
  - 어플리케이션 생성/ 확인
    - Docker hub에 올린 이미지를 통한 컨테이너 생성
      "kubectl create deploy my-nginx --image=apexacme/my-nginx:v1"
    - 클러스터 외부에 노출하기
      "kubectl expose deploy my-nginx --type=LoadBalancer --port=80"
  - 서비스 확인하기
    - kubectl get svc의 EXTERNAL-IP 복사
    - Browser에서 EXTERNAL-IP:80 접속
    
- <b>Lab. Pod & 기본명령</b>
  - kubectl get nodes
    - 쿠버네티스에 제대로 접속했는지 확인
    - 현 클러스터의 워크노드를 리스트업
    - 접속 결과 안나오는 경우
      - kubectl config current-context 명령으로 Cluster 접속 확인
  - 객체의 검색
    - kubectl get [object type]
    - kubectl get pods   # pods = pod = po
    - kubectl get deployments   # deploy
    - kubectl get services    # svc
    - kubectl get replicaset    # rs
  - 객체의 모니터링
    - watch kubectl get all
    - kubectl get pod -w
    - watch kubectl get pod
  - 객체의 유형
    - Service 
      - types
        - LoadBalancer
          - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
          - front-end 혹은 ingress (api gateway)
        - ClusterIP(default) / NodePort
          - 클러스터 내부 IP
          - 내부 마이크로 서비스
    - Deployment
      - ReplicaSet (하나이상 생성)
        - Pod (하나이상 생성)
          - Container (docker ) 하나이상.
    - Pod
    - ReplicaSet
    - Ingress
    - Secret
    - ConfigMap
    - ServiceAccount = sa
    - statefulset
    - daemonset
  - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
    - nano declarative-pod.yaml
      "apiVersion: v1
      kind: Pod
      metadata:
        name: declarative-pod
        labels:
          env: test
      spec:
        containers:
        - name: memory-demo-ctr
          image: nginx"
    - 저장 및 종료 (ctrl + X, Y, 엔터)
    - kubectl create -f declarative-pod.yaml
    - kubectl get pods
  - 원하는 Node 타입에 Pod 생성
    - #pwd 로 현 위치가 /container-orchestration/yaml_aws/pod 인지 확인
    - kubectl create -f pod-with-nodeselector.yaml
    - kubectl get po -o wide
      - Pod가 찾는 노드가 없어 pending 상태
    - 노드에 라벨 추가
      - kubectl label nodes <your-node-name> disktype=ssd
      - kubectl get nodes --show-labels | grep ssd
    - kubectl get po -o wide
  - Pod 생성 전 초기화  
    - kubectl create -f pod-initialize.yaml
    - kubectl get po
    - #생성된 Pod 내로 접근
    - kubectl exec -it init-demo -- /bin/bash 
    - cd /usr/share/nginx/html
    - ls
  - 생성된 Pod, 및 오브젝트 삭제
    - kubectl delete pod [pod명]
    - kubectl delete service,deploy --all

- <b>Lab. Label </b>
  - 2개의 Pod 생성
  - (1. pod 폴더로 이동하여, 아래 명령어 실행)
  - kubectl create -f pod-with-nodeselector.yaml 
  - (2. 아래 nginx 컨테이너 생성)
  - kubectl run nginx2 --image=nginx
  - kubectl get pods -l run=nginx2
  - kubectl get pods --selector run=nginx2
  - kubectl get pods --selector 'run in (nginx2, test)'
- <b>Lab. Rollout & RollBack</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인)
  - kubectl create -f nginx.yaml
  - (아래 명령으로 배포 주석 추가, Rollback시 필요) 
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
  - Set image 명령을 통한 이미지 Rollout  및 확인
  - kubectl set image deploy nginx-deployment nginx=nginx:1.9.1
  - kubectl rollout history deploy nginx-deployment
  - (배포주석 달기)
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is revisioned nginx:1.9.1'
  - kubectl describe po <해당 deployment 의 pod 중 하나의 이름>    # 내용의 image 부분이 1.9.1 인지 확인
  - (무정지 재배포 히스토리 확인)
  - kubectl rollout history deploy nginx-deployment
  - (다음과 같이 출력됨을 확인)
    "REVISION  CHANGE-CAUSE
      1         v1 is nginx:1.7.9
      2         v2 is nginx:1.9.1"
  - (롤백하기)
  - kubectl rollout undo deploy nginx-deployment
  - kubectl rollout undo deploy nginx-deployment --to-revision 1
- <b>Lab. ReplicaSet</b>
  - pwd 로 현 위치가 /container-orchestration/yaml_aws/replicaset 인지 확인
  - kubectl create -f replicaset.yaml
  - kubectl get all
  - #replica 개수 조정
    - kubectl scale replicaset/frontend --replicas=5
    - kubectl get po 
- <b>Lab. Deployment & 기본명령 </b>
  - 기본 nginx 서버의 배포
  - kubectl create deploy nginx --image=nginx
  - kubectl get deploy nginx
  - kubectl get replicaset -l app=nginx
  - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
  - kubectl describe po (검색한 pod name)
  - (pod 제거)
  - kubectl delete po --all   # 
  - (pod 를 제거해도 재생됨을 확인)
  - kubectl get po
  - (scale out)
  - kubectl scale deploy nginx --replicas=3
  - kubectl get po   # pod 개수가 3개로 늘어남을 확인
  - kubectl delete po --all   # pod 를 모두 지움
  - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
  - ( 제거하기 위해서는 deployment 를 제거해야만 함)
  - kubectl delete deploy nginx
- <b>Auto Scale-Out </b>
  - pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인
  - (모든 객체 지우기)
  - kubectl delete deploy,service --all
  - (대상 서비스 배포 및 모니터링)
  - kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
    - NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함
      " resources:
            limits:
              cpu: 500m
            requests:
              cpu: 200m"
  - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )

    - kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10
      "cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)"
    - kubectl get hpa php-apache -o yaml
  - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
    - cat siege.yaml
    - kubectl create -f siege.yaml
    - kubectl exec -it siege -- /bin/bash
  - 로드 생성
    - siege -c30 -t30S -v http://php-apache
  - (오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)
    - metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인 
    - 디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인
    - cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음
- <b>Lab. Service</b>
  - Basic YAML 
    "apiVersion: v1
      kind: Service
      metadata:
        name: my-service
      spec:
        selector:
          app: MyApp
        ports:
          - protocol: TCP
            port: 80
            targetPort: 8080"
  - kubectl delete service,deploy --all  # 기존 이력 삭제 
  - (다시 생성)
  - kubectl create deploy nginx --image=nginx
  - (서비스로 노출)
  - kubectl expose deploy nginx --type="LoadBalancer" --port=80
  - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
  - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
- <b>Lab. Volume</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/volume 인지 확인)
  - (emptyDir 마운트)
  - kubectl create -f volume-emptydir.yaml
  - (GitRepository를 볼륨으로 마운트)
  - kubectl create -f volume-gitrepo.yaml
  - (EFS - Elastic File System 생성하기)
    - 관리콘솔에서 EFS 생성
    - EFS Service Account 생성 : efs-sa.yaml 실행
    - EFS Provisioner 배포 : 
      - 관리콘솔에서 생성한 efs ID와 DNS 정보로 수정 
      - nano efs-provisioner-deploy.yaml 
      - efs-provisioner-deploy.yaml 실행
    - SA 권한 설정 :  efs-rbac.yaml 실행
    - StorageClass 생성 :  efs-storageclass.yaml 실행
  - (PersistentVolumeClaim 생성)
  - kubectl create -f volume-pvc.yaml
  - kubectl get pvc 
  - kubectl describe pvc aws-efs
  - (생성된 PersistentVolueClaim으로 Pod 생성하기)
  - kubectl create -f pod-with-pvc.yaml
  - kubectl describe pod mypod
  - (포드 접속)
  - kubectl exec -it mypod -- /bin/bash
  - (마운트 및 사이즈 확인)
  - df -k
- <b>Lab. ConfigMap</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/configmap/ 인지 확인)
  - (컨피그 맵 생성)
  - kubectl create configmap hello-cm --from-literal=language=java
  - kubectl get cm
  - kubectl get cm hello-cm -o yaml
  - (도커라이징 & ECR Push)
    - docker build -t 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1 .
    - aws ecr create-repository --repository-name user22-cm-sandbox --region ap-northeast-2
    - docker push 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1
  - (인증오류 발생 시, ECR 로그인)
    - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/
    - 오류(unknown flag: --password-stdin) 발생 시,
      - docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/
  - 클라우드에서 배포 이미지 확인
  - nano cm-deployment.yaml 파일 편집(나의 ECR Registry 정보로 수정)
  - (배포 및 서비스 생성)
    - kubectl create -f cm-deployment.yaml
    - kubectl create -f cm-service.yaml
  - (서비스 확인)
    - Service의 External-IP 접속
- <b>Lab. Secret</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/secret/ 인지 확인)
  - kubectl create secret generic my-password --from-literal=password=mysqlpassword
  - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
- <b>Lab. Liveness & Readiness Probe</b>
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/liveness/ 인지 확인)
  - (Liveness Command Probe 실습)
    - kubectl create -f exec-liveness.yaml 
    - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-exec
  - (Liveness HTTP Probe 실습)
    - kubectl create -f http-liveness.yaml
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-http
  - (Liveness 와 readiness probe 동시 적용 실습)
    - kubectl create -f tcp-liveness-readiness.yaml
    - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
    - kubectl describe po goproxy    
</details>

<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>

  - <b>Lab. Ingress</b>
    - Helm 명령으로 설치 여부 확인
    - Helm이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
      - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
      - (설치 중, sudo를 위한 비밀번호 입력) 
      - (Helm 초기화 설정)
      - (Helm 설치 관리자를 위한 시스템 사용자 생성)
      - kubectl --namespace kube-system create sa tiller 
      - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
      - helm init --service-account tiller
      -  (kubectl config current-context 명령으로 클러스터명 확인)
    - Helm으로 Ingress Controller 설치
      - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
      - helm repo update
      - kubectl create namespace ingress-basic
      - helm install --name nginx-ingress stable/nginx-ingress --namespace=ingress-basic 
      - (설치확인)
        - kubectl get all --namespace=ingress-basic
        - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
    - Ingress 대상 서비스(BLUE, GREEN) 생성
      - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/blue-svc/ 인지 확인)
        - (도커라이징 & 이미지 Push)
        - docker build -t 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest  .
        - aws ecr create-repository --repository-name user30-nginx-blue --region ap-northeast-2
        - docker push 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest 
        - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
        - nano nginx-blue-deployment.yaml
        - (저장 ctrl + X)
        - (배포 및 서비스 생성)
        - kubectl create -f nginx-blue-deployment.yaml  
      - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/green-svc/ 인지 확인)
        - (도커라이징 & 이미지 Push)
        - docker build -t (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest  .
        - aws ecr create-repository --repository-name nginx-green --region ap-northeast-2
        - docker push (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest
        - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
        - nano nginx-green-deployment.yaml
        - (저장 ctrl + X)
        - (배포 및 서비스 생성)
        - kubectl create -f nginx-green-deployment.yaml 
      - (서비스 생성 확인)
        - kubectl get deploy,service -n ingress-basic
    - Ingress Routing Rule 생성
      - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/ 인지 확인)
      - kubectl apply -f path-based-ingress.yaml
      - kubectl get ingress -n ingress-basic
    - Ingress 테스트
      - API Gateway 주소를 Local 시스템에 등록
      - Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록   
  - <b>Metric Server 설치</b>
    - kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml
    - kubectl get deployment metrics-server -n kube-system
  - <b>AWS EKS 모니터링</b>
    - Metric-Server 설치
      - kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml
    - Kubernetes DashBoard 설치
      - kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml
    - eks-admin 서비스 계정 및 클러스터 롤 바인딩 생성
      ```
      "cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: eks-admin
          namespace: kube-system
        ---
        apiVersion: rbac.authorization.k8s.io/v1beta1
        kind: ClusterRoleBinding
        metadata:
          name: eks-admin
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: cluster-admin
        subjects:
        - kind: ServiceAccount
          name: eks-admin
          namespace: kube-system
        EOF"
        ```
    - 인증 토큰 조회
      - kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep eks-admin | awk '{print $1}')
    - Proxy 설정 및 DashBoard 연결
      - kubectl proxy
      - http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login
      - 복사한 토큰 정보로 로그인
</details>
 
<details>
<summary><b>Real MSA Application Deployment</b></summary>
   
  - <b>사전작업</b>
    - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com
    - cd  ~
    - mkdir MSA-Sample
    - cd MSA-Sample
  - <b>마이크로서비스 배포</b>
    - 상품(Product) 서비스 
      "export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com
        git clone https://github.com/event-storming/reqres_products.git
        cd reqres_products
        mvn package -Dmaven.test.skip=true

        docker build -t ${ECR}/products:latest .
        aws ecr create-repository --repository-name products --region ap-northeast-2
        docker push ${ECR}/products:latest

        kubectl create deploy products --image=${ECR}/products:latest
        kubectl expose deploy products --type="ClusterIP" --port=8080
        cd .."
    - 주문(Order) 서비스 
      "export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com      
      git clone https://github.com/event-storming/reqres_orders.git 
            
      cd reqres_orders 
      export IMAGENAME=orders       
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 배송(Delivery) 서비스
      "git clone https://github.com/event-storming/reqres_delivery.git
      cd reqres_delivery
      export IMAGENAME=delivery
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 인증(Oauth) 서비스 
      "git clone https://github.com/event-storming/oauth.git
      cd oauth
      export IMAGENAME=oauth
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 게이트웨이(Gateway) 서비스
      "git clone https://github.com/event-storming/gateway.git
      cd gateway
      export IMAGENAME=gateway
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
    - 프론트-엔드(UI) 서비스: 빌드환경 설정(npm 설치) 
      "sudo apt-get update
      sudo apt install build-essential
      curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
      sudo apt install nodejs
      "
    - 프론트-엔드(UI) 서비스: 배포 사전 작업
      "git clone https://github.com/event-storming/ui.git
      cd ui
      export IMAGENAME=ui
      
      npm install
      npm run build
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      
      _GATEWAY_IP=$(kubectl get -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" svc gateway --ignore-not-found)
      echo ${_GATEWAY_IP}"
    - 프론트-엔드(UI) 서비스: 배포 및 서비스 생성
      ```
      "cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${IMAGENAME}
        labels:
          app: ${IMAGENAME}
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ${IMAGENAME}
        template:
          metadata:
            labels:
              app: ${IMAGENAME}
          spec:
            containers:
              - name: ${IMAGENAME}
                image: ${ACR}/${IMAGENAME}:latest
                ports:
                  - containerPort: 8080
                env:
                  - name: VUE_APP_API_HOST
                    value: http://${_GATEWAY_IP}:8080
      EOF
      
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
      ```
      
  - <b>서비스 확인</b>
    - kubectl get svc ui
    - 브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080

</details>

<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>

  - <b>Lab. Istio Install</b>
    - Istio 설치
    - curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -
      "(istio v1.7.1은 Kubernetes 1.16이상에서만 동작)"
    - cd istio-1.7.1
    - export PATH=$PWD/bin:$PATH
    - istioctl install --set profile=demo
      "note : there are other profiles for production or performance testing."
    - Istio 모니터링 툴(Telemetry Applications) 설치
      - kubectl apply -f samples/addons
      - 모니터링(Tracing & Monitoring) 툴 설정
        - Monitoring Server - Kiali
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc kiali -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
        - Tracing Server - Jaeger
          - 기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로..
            - kubectl edit svc tracing -n istio-system
            - :%s/ClusterIP/LoadBalancer/g
            - :wq!
          - 분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80
    - 설치확인
      - kubectl get all -n istio-system
  - <b>How to enable Istio</b>
    - 1. Whenever deploying to Cluster, Using pre-processing command 'Istio kube-inject'
      - kubectl apply -f <(istioctl kube-inject -f Deployment.yml) -n istio-test-ns
    - 2. Using Istio-enabled Namespace.  
      - e.g. kubectl label namespace istio-test-ns istio-injection=enabled
  - <b>Lab. Istio Tutorial 셋업</b>
    - Git repository에서 Tutorial 리소스 가져오기
      - cd ~
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - 네임스페이스 생성
      - kubectl create namespace tutorial
    - Customer Service 배포
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
        - kubectl describe pod (Customer Pod) -n tutorial 로 생성확인
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
    - Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
      - cat customer/kubernetes/Gateway.yml 
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
      - (Istio-IngressGateway를 통한 Customer 서비스 확인)
        - kubectl get service/istio-ingressgateway -n istio-system
        - 해당 EXTERNAL-IP가 Istio Gateway 주소
        - Customer 서비스 호출 : 
          "http://(istio-ingressgateway IP)/customer"
    - Preference, Recommendation-v1 Service 배포
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
  - <b>Lab. Istio - Traffic Routing</b>
    - Simple Routing
      - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
      - (recommendation 서비스 추가 배포: v2)
        - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
      - 서비스 호출
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
        - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
      - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
    - (Recommendation v.2 서비스 Scale Out)
    - (서비스의 v2 의 replica 를 2로 설정)
      - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
      - kubectl get po -n tutorial
    - Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출
    - Routing 결과 확인 - Kiali(Externl-IP:20001) 접속
    - Advanced Routing
      - 정책(VirtualService, DestinationRule) 설정
        - (현, 정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
        - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
          - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
        - (설정정책 확인)
          - kubectl get VirtualService -n tutorial -o yaml
          - kubectl get DestinationRule -n tutorial -o yaml
        - (서비스 확인)
          - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
          - Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링
      - 가중치 기반 스마트 라우팅
        - (recommendation 서비스 v1의 가중치를 100으로 변경)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
        - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
          - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
        - Canary 라우팅 비율별 배포 정책 예시
          - (90 : 10)
          - kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
          - (75 : 25)
          - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - #kubectl delete vs recommendation -n tutorial
          - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
      - Client 브라우저 유형별 스마트 라우팅
        - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
          - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
          - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
        - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
        - (Browser 환경이 지원되지 않을 경우,)
          - curl -A Safari Externl-IP:8080
          - curl -A Firefox Externl-IP:8080
        - 삭제
          - kubectl delete dr recommendation -n tutorial
          - kubectl delete vs recommendation -n tutorial
  - <b>Lab. Istio - Timeout & Retry</b>
    - Lab에 필요한 모듈(Message Queue) 설치
      - kubectl get svc my-kafka -n kafka
      - 미설치시, 설치 링크 (https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629)
    - tutorial  네임스페이스에 Istio 기능 추가
      - kubectl label namespace tutorial istio-injection=enabled --overwrite
      - 네임스페이스가 없을 시, 생성 후 실행
    - Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
      - Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
        - Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입
          ```
          "  @PrePersist
              public void onPrePersist(){  
                  try {
                      Thread.currentThread().sleep((long) (800 + Math.random() * 220));
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }"
              ```
        - Docker image Build & Push
        - tutorial 네임스페이스에 Order v2 서비스 재배포  
          ```
          "kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: order
              namespace: tutorial
              labels:
                app: order
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: order
              template:
                metadata:
                  labels:
                    app: order
                spec:
                  containers:
                    - name: order
                      image: IMAGE_FULL_REPOSITORY_URL/order:v2
                      ports:
                        - containerPort: 8080
                      resources:
                        limits:
                          cpu: 500m
                        requests:
                          cpu: 200m
            EOF"
            ```
        - Order 서비스 생성
          - kubectl expose deploy order --port=8080 -n tutorial
        - Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시) 
          - (pwd 로 현 위치가 /istio-tutorial/ 인지 확인)
          - nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가
            ```
            "- match:
                - uri:
                    prefix: /orders
                route:
                - destination:
                    host: order
                    port:
                      number: 8080
                timeout: 3s"
              ```
          - (변경 내용 적용)
          - kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial
        - Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)
          ```
          "kubectl apply -f - <<EOF
              apiVersion: networking.istio.io/v1alpha3
              kind: VirtualService
              metadata:
                name: vs-order-network-rule
                namespace: tutorial
              spec:
                hosts:
                - order
                http:
                - route:
                  - destination:
                      host: order
                  timeout: 3s
              EOF"
              ```
        - 부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing 
          - kubectl run siege --image=apexacme/siege-nginx -n tutorial 
          - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
          - siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'
      - Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인
    - Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule 
      - Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포
      - Docker image Build & Push
      - tutorial 네임스페이스에 Delivery 서비스 배포  
        ```
        "kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: delivery
            namespace: tutorial
            labels:
              app: delivery
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: delivery
            template:
              metadata:
                labels:
                  app: delivery
              spec:
                containers:
                  - name: delivery
                    image: IMAGE_FULL_REPOSITORY_URL/delivery:v2
                    ports:
                      - containerPort: 8080
                    resources:
                      limits:
                        cpu: 500m
                      requests:
                        cpu: 200m
          EOF"
          ```
      - Delivery 서비스 생성
        - kubectl expose deploy delivery --port=8080 -n tutorial
      - Order 서비스에 Retry Rule 추가 적용
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: vs-order-network-rule
            namespace: tutorial
          spec:
            hosts:
            - order
            http:
            - route:
              - destination:
                  host: order
              timeout: 3s
              retries:
                attempts: 3
                perTryTimeout: 2s
                retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
          EOF"
          ```
      - Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
        - kubectl scale deploy delivery --replicas=0 -n tutorial
        - kubectl exec -it siege -c siege -n tutorial -- /bin/bash
        - http http://order:8080/orders/ productId=1001 qty=5
          - httpie가 없을 시,
          - apt-get update
          - apt-get install httpie
        - http DELETE http://order:8080/orders/1 
      - Jaeger 접속(http://tracing svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기
        "< 검색조건 >
          Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*
          검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅"
  - <b>Lab. Istio - Circuit Breaker</b>
    - Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)
    - Namespace 생성 및 Istio 활성
      - kubectl create namespace istio-cb-ns
      - kubectl label namespace istio-cb-ns istio-injection=enabled
    - Istio Retry 디폴트 동작 확인  
      - 테스트 어플리케이션 배포
        - hello-server-1, hello-server-2 Pods, Service
        - hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함
          ```
          "kubectl apply -f - << EOF
              apiVersion: v1
              kind: Pod
              metadata:
                name: hello-server-1
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                containers:
                - name: hello-server-1
                  image: docker.io/honester/hello-server:latest
                  imagePullPolicy: IfNotPresent
                  env:
                  - name: VERSION
                    value: "v1"
                  - name: LOG
                    value: "1"
              ---
              apiVersion: v1
              kind: Pod
              metadata:
                name: hello-server-2
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                containers:
                - name: hello-server-2
                  image: docker.io/honester/hello-server:latest
                  imagePullPolicy: IfNotPresent
                  env:
                  - name: VERSION
                    value: "v2"
                  - name: LOG
                    value: "1"
                  - name: RANDOM_ERROR
                    value: "0.2"
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: svc-hello
                namespace: istio-cb-ns
                labels:
                  app: hello
              spec:
                selector:
                  app: hello
                ports:
                - name: http
                  protocol: TCP
                  port: 8080
              EOF"
              ```
        - 클라이언트용 서비스(httpbin) 배포
          ```
          "kubectl apply -f - <<EOF
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: httpbin
                namespace: istio-cb-ns
              spec:
                replicas: 1
                selector:
                  matchLabels:
                    app: httpbin
                template:
                  metadata:
                    labels:
                      app: httpbin
                  spec:
                    containers:
                    - name: httpbin
                      image: docker.io/honester/httpbin:latest
                      imagePullPolicy: IfNotPresent
                      ports:
                      - containerPort: 80
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: httpbin
                namespace: istio-cb-ns
                labels:
                  app: httpbin
              spec:
                selector:
                  app: httpbin
                ports:
                - name: http
                  port: 8000
                  targetPort: 80
              EOF"
              ```
      - Retry 디폴트 동작 테스트
        - hello-server-2의 로그 모니터 걸기
          - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - 클라이언트에서 svc-hello 서비스 10번 호출하기
          - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
      - 결과 확인/분석
        "1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
          2) 핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)"
    - Circuit Breaker 설정
      - 대기 쓰레드수 기반 Circuit Breaker
        - 클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정 
        - (Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking) 
          ```
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-httpbin
              namespace: istio-cb-ns
            spec:
              host: httpbin
              trafficPolicy:
                connectionPool:
                  http:
                    http1MaxPendingRequests: 1
                    maxRequestsPerConnection: 1
            EOF"
            ```
        - Circuit Breaker 동작 확인 
          - 부하테스트 툴(Siege) 설치 및  Load Testing 
            - kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns
            - kubectl exec -it siege -c siege -n istio-cb-ns -- /bin/bash
              - siege -c1 -t10S -v http://httpbin:8000/get  # 100% availability
              - siege -c2 -t10S -v http://httpbin:8000/get  # 87% availability
          - Kiali(Externl-IP:20001) 모니터링
      - 로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker 
        - Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정
          ```
          "kubectl apply -f - <<EOF
            apiVersion: networking.istio.io/v1alpha3
            kind: DestinationRule
            metadata:
              name: dr-hello-server
              namespace: istio-cb-ns
            spec:
              host: svc-hello
              trafficPolicy:
                outlierDetection:
                  interval: 1s
                  consecutiveErrors: 1
                  baseEjectionTime: 3m
                  maxEjectionPercent: 100
            EOF"
            ```
        - Circuit Breaker 동작 확인 
          - 클라이언트(httpbin Pod)에서 svc-hello 호출 
            - hello-server-2의 로그 모니터 걸기
              - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
            - 클라이언트에서 svc-hello 서비스 10번 호출하기
              - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
            - 결과 확인/분석
              "1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다. 
                2) 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인"
    - 동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
      - Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-delivery
            namespace: tutorial
          spec:
            host: delivery
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 30
                  maxRequestsPerConnection: 100
              outlierDetection:
                interval: 5s
                consecutiveErrors: 1
                baseEjectionTime: 5m
                maxEjectionPercent: 100
          EOF"
          ```
      - 설정 내용
        - 최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)
        - 5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)
        - 또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음
    - Clean-up
      - kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns
  - <b>Clear Istio </b>
    - kubectl delete ns tutorial istio-cb-ns istio-system

</details>


<details>
<summary><b>Backup</b></summary>
    
  - <b>Container로부터 이미지 생성</b>
    - 이미지 생성
      - docker run --name my-nginx -d -p 80:80 nginx
      - docker exec -it my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - cd /usr/share/nginx/html
        - echo 'Hello my name is PYJ.' >> index.html
        - exit
      - docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성
      - docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인
      - docker commit -a "apex@naver.com" -m "update nginx" my-nginx my-nginx:1.0 
      - docker images
      - docker stop my-nginx
      - docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0
      - http://localhost 확인
      - docker stop my-nginx2
    - 이미지 푸시
      - docker tag my-nginx:1.0 apexacme/my-nginx:1.0
      - docker images
      - docker push apexacme/my-nginx:1.0
      - http://hub.docker.com 에서 이미지 확인
    - 도커허브 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0
      
  - <b>샘플 자바 애플리케이션 패키징과 배포 </b>
    - (pwd 로 현 위치가 /container-orchestration_aws/ 인지 확인)
    - git clone https://github.com/event-storming/monolith.git
    - cd monolith/
    - ls
    - (skip) mvn spring-boot:run #Maven으로 App. 실행 
    - mvn package -B -Dmaven.test.skip=true
    - (skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행
    - cat Dockerfile # 도커파일 내용 확인
    - (도커라이징)
      - docker build -t (Azure container registry명).azurecr.io/monolith:v1 .     
        - #주의1 :   명령  맨끝에 " ." 빼먹으면 안됨.   Dockerfile 의 위치인
        - #주의2 :   project id 부분을 자신의 GCP project id 로 변경!!
        - #주의3 :   현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함
      - docker images
      - (skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행
      - docker push (azure container registry명).azurecr.io/monolith:v1
    - kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1
    - kubectl get po -l app=monolith
    - kubectl expose deploy monolith --type="LoadBalancer" --port=8080
    - kubectl get svc -w
    - 자바 애플리케이션 접속
      - http://(Service_Extern-IP):8080
  - <b>Lab. Circuit Breaking</b>
    - Istio가 활성화된 네임스페이스 생성 
      - kubectl create namespace istio-cb-ns
      - kubectl label namespace istio-cb-ns istio-injection=enabled
    - [CB 유스케이스] #1. Connection Max & Pending 수에 따른 Circuit Breaker
      - 테스트 어플리케이션 배포 (Deployment, Service)
        ```
        "kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: httpbin
            namespace: istio-cb-ns
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: httpbin
            template:
              metadata:
                labels:
                  app: httpbin
              spec:
                containers:
                - name: httpbin
                  image: docker.io/honester/httpbin:latest
                  imagePullPolicy: IfNotPresent
                  ports:
                  - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: httpbin
            namespace: istio-cb-ns
            labels:
              app: httpbin
          spec:
            selector:
              app: httpbin
            ports:
            - name: http
              port: 8000
              targetPort: 80
          EOF"
          ```
      - 로드 테스트 툴(siege) 배포
        ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: siege
            namespace: istio-cb-ns
          spec:
            containers:
            - name: siege
              image: apexacme/siege-nginx
          EOF"
          ```
      - siege를 통한 서비스(httpbin) 부하 생성
        - kubectl exec -it siege --container siege -n istio-cb-ns -- /bin/bash
        - siege -c1 -t10S -v http://httpbin:8000/get
        - siege -c1 -t10S -v http://httpbin.istio-cb-ns:8000/get
        - siege -c1 -t10S -v http://httpbin.istio-cb-ns.svc.cluster.local:8000/get
        - 서비스 모니터링 (Kiali) : EXTERNAL-IP:20001 (admin/admin)
      - DestinationRule 를 생성하여 CB가 발생할 수 있도록 Connection pool 설정 
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-httpbin
            namespace: istio-cb-ns

          spec:
            host: httpbin
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 1
                  maxRequestsPerConnection: 1
          EOF"
          ```
        - http1MaxPendingRequests=1 : Queue에서 Connection pool 에 연결을 기다리는 request 수를 1개로 제한
        - maxRequestsPerConnection=1 : keep alive 기능 disable 
      - siege를 통한 서비스(httpbin) 부하 재생성 및 CB 확인
        - siege -c1 -t10S -v http://httpbin:8000/get  # 100% Availability
        - siege -c2 -t10S -v http://httpbin:8000/get  # 87% availability
          - Envoy will return HTTP 503. It is the responsibility of the application to implement any fallback logic that is needed to handle the HTTP 503 error code from an upstream service. (https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html) 
        - 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)
      - Circuit Breaker 제거 후, 동일 로드 생성 후, Availability 100% 확인
        - kubectl delete dr/dr-httpbin -n istio-cb-ns
        - siege -c2 -t10S -v http://httpbin:8000/get  # 100% availability
      - Clean-up
        - kubectl delete deployment.apps/httpbin service/httpbin -n istio-cb-ns
    - Istio - Circuit Breaker
      - 테스트 어플리케이션 배포 (hello-server-1, hello-server-2 Pods, Service)
      - (hello-server:latest 이미지는 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함)
        ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: hello-server-1
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            containers:
            - name: hello-server-1
              image: docker.io/honester/hello-server:latest
              imagePullPolicy: IfNotPresent
              env:
              - name: VERSION
                value: "v1"
              - name: LOG
                value: "1"
          ---
          apiVersion: v1
          kind: Pod
          metadata:
            name: hello-server-2
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            containers:
            - name: hello-server-2
              image: docker.io/honester/hello-server:latest
              imagePullPolicy: IfNotPresent
              env:
              - name: VERSION
                value: "v2"
              - name: LOG
                value: "1"
              - name: RANDOM_ERROR
                value: "0.2"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: svc-hello
            namespace: istio-cb-ns
            labels:
              app: hello
          spec:
            selector:
              app: hello
            ports:
            - name: http
              protocol: TCP
              port: 8080
          EOF"
          ```
      - 클라이언트용 Pod 설치
        ```
        "kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: httpbin
            namespace: istio-cb-ns
            labels:
              app: httpbin
          spec:
            containers:
            - name: httpbin
              image: docker.io/honester/httpbin:latest
              imagePullPolicy: IfNotPresent
          EOF"
          ```
      - 클라이언트(httpbin Pod)에서 svc-hello 호출(default, Round-Robin)
        - (hello-server-2의 로그 모니터링)
        - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - (클라이언트에서 svc-hello 서비스 10번 호출하기)
        - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
      - 5XX 오류에 대해 해당 서비스 차단 및 Thread 부하에 따른 Circuit Breaker 생성
        ```
        "kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: DestinationRule
          metadata:
            name: dr-delivery
            namespace: istio-cb-ns
          spec:
            host: delivery
            trafficPolicy:
              connectionPool:
                http:
                  http1MaxPendingRequests: 1
                  maxRequestsPerConnection: 1
              outlierDetection:
                interval: 1s
                consecutiveErrors: 1
                baseEjectionTime: 3m
                maxEjectionPercent: 100
          EOF
          ```

          설명 : 1초 주기로 이상징후를 체크하며, 1번이라도 실패한 서비스는 3분동안 라우팅 대상에서 제외된다. 또한 모든 대상 서비스 인스턴스가 방출(제외)될 수 있다."
      - 클라이언트(httpbin Pod)에서 svc-hello 호출 및 CB 확인
        - (hello-server-2의 로그 모니터링)
        - kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns
        - (클라이언트에서 svc-hello 서비스 10번 호출하기)
        - for i in {1..10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns -- curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done
        - 모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)
      - Clean-up
        - kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns

  - <b>Lab. Istio Egress</b>
    - 외부 도메인을 호출하는 v3 버전을 배포
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
    - v3에서 날짜정보가 추가로 출력됨을 확인
    - Istio 트래픽을 등록된 것만 허용하도록 변경
      - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인
    - 트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
      - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial
      - kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - 화면에 Error Log 출력 : “customer => Error: 503 - preference => Error: 500”
    - 외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
      - kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력
    - (테스트 후, 설정 복구)
    - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g' | kubectl replace -n istio-system -f -
    
</details>



</p>
</details>
<hr />

<br />


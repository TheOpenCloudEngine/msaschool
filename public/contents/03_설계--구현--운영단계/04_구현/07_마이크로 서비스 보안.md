## 마이크로 서비스 보안

모노리스 시스템에서 인증, 권한 부여 및 기타 다양한 중요 보안 조치를 다루는 중앙 집중식 보안 모듈을 사용하는 경우가 많았다. 그러나 마이크로 서비스에서 중앙 집중화는 분산 배포의 이점을 떨어뜨리고, 효율성을 감소시킨다. 
결국 중앙 집중식 세션 관리보다 확장 가능한 방법이 요구 되어지는데, 모든 마이크로 서비스에서 보안 모듈을 심기 보다는 단일 진입점을 제공하는  API 게이트웨이에서 처리하는 것이 효율적이다. 이 API 게이트웨이에서 사용자 체크와 서비스에 접근 할 수 있는 권한 부여 및 인증을 처리하게 된다.  

##### 이번 장에서는 인증/인가의 정확한 개념과 Rest API 를 인증 하는 방법을 나열하고, 그중 Rest API 인증의 의 표준 격인 Oauth 2.0 에 대하여 설명을 한다. 

## 인증/인가

인증(Authentication) 과 인가(Authorization)란?

1. 인증(Authentication)
    - 사용자인지 아닌지를 확인. 주로 아이디/패스워드 인증이 많이 사용되나 생체인식 등의 인증도 사용.
    - 서비스를 호출하는 서비스 클라이언트가 자신이라는 것을 어떻게 알 수 있을까?
    - who you are
    - 사원증 발급
2. 인가(Authorization)
    - 사용자가 권한이 있는지 없는지 확인하여 해당 행위를 제한하거나 가능하게 하게 함.
    - 마이크로서비스를 호출하는 서비스 클라이언트가 수행하려는 작업을 수행할 자격이 있는지 어떻게 알 수 있을까?
    - what you can do
    - 사원증 찍고 게이트 통과

## Rest API 인증 방법 

1. HTTP Basic Authentication

- 사용자 이름과 암호 Base 64 인코딩을 하여 서버로 전송.
- 요청 할 때 마다 사용자 이름과 암호를 전송해야 한다.
- 중간자 공격(Man-in-the-middle attack)에 취약하다.

2. Cookies and Session

- 세션은 키를 사용자 아이디에 매핑한다.
- 세션이 존재하는 경우 키가 유효한 것으로 판단합니다.
- 매 요청마다 쿠키에서 키를 보내 인증을 하여 세션이 유효한지 판단한다.
- REST API 의 기본 원칙인 Stateless에 위배 된다.

3. API Keys

- 로그인 후 API키를 받아서 전달받아서 매 요청시마다 API키를 전달하는 방법.
- API키가 유출될시 보안문제가 생길 수 있다.
- 주기적으로 키를 업데이트 하더라도, 서버와 클라이언트가 잘 맞지 않으면 서비스 장애로 이어진다.
- Cloud 의 상징인 Auto Scaling 등으로 서버의 수가 변하고 IP가 유동적이라면 사실 상 관리가 되지 않는다. 

4. OAuth 2.0 (Token in HTTP Header)

- API Key의 단점을 보완하여 요청하는 서버와 요청받는 서버 정도로 단순한 구성이 아닌, 요청하는 서버, 요청받는 서버, 그리고 인증하는 서버 등으로 조금 세분화가 이루어진다. (중립적인 위치에서 인증을 전담하는 구조)
- OAuth 1.0 보다 인증 절차를 간소화 하고 다양한 인증 방식을 지원 한다.
- OAuth 1.0 은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워짐

## Oauth 2.0 

![flow](/img/03_Bizdevops/04/07/oauth2flow.png)

![Authorization_Code](/img/03_Bizdevops/04/07/Authorization_Code_Grant_Type.png)
![Implicit](/img/03_Bizdevops/04/07/Implicit_Grant_Type.png)
![Password](/img/03_Bizdevops/04/07/Password_Grant_Type.png)
![Client_Credential](/img/03_Bizdevops/04/07/Client_Credential_Grant_Type.png)

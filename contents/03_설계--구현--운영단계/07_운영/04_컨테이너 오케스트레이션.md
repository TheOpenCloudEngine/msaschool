## 컨테이너 오케스트레이션 Lab. Guide 

<br/>

### 구글 (Google) Cloud
<details>
<summary>Google Cloud Platform 기반의 Container Orchestration Lab. Scripts</summary>
<p>

<details>
<summary><b>자주 사용되는 Cloud Commands</b></summary>

  - Cloud Configuration
    - gcloud init

  - GCP 클러스터 생성
    - gcloud container clusters create cluster-2 --zone asia-northeast3-a --enable-cloud-logging --enable-cloud-monitoring --subnetwork default
    
  - GCP 클러스터 토큰 가져오기
    - gcloud container clusters get-credentials cluster-1 --zone asia-northeast1-a --project project-name
  - GCP 컨테이너 레지스트리 로그인
    - gcloud auth configure-docker
  - GCP 레지스트리에 도커 이미지 푸시하기
    - gcloud docker -- push gcr.io/project-for-msaschool/nginx:v1 (docker 18.03 이하)
    
</details> 
    
### Docker

<details>
<summary><b>Docker Hands-on</b></summary>

  - Lab. image
    - 이미지 Pull
      - docker pull hello-world
      - docker images 
      - docker pull nginx
      - docker pull nginx:latest
      - docker pull docker.io/library/nginx:latest
      - docker pull nginx:1.16.1
      - docker images
    - 도커허브 (Docker Hub, 가입) 
      - http://hub.docker.com # 접속 후, nginx 검색 
    - 이미지 Tagging
      - docker image tag nginx my-nginx # Create 태그
    - 이미지 삭제
      - docker image rm my-nginx
      - docker image rm hello-world
      - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
      
  - Lab. container
    - 컨테이너 생성
      - docker run hello-world # 컨테이너 만들기
      - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
      - docker run --name my-nginx -d -p 8080:80 nginx
      - docker ps
    - 컨테이너 시작/종료
      - docker stop my-nginx
      - docker start my-nginx
    - 컨테이너 포트 노출
      - http://localhost 에서 nginx index.html 확인
      - docker container rm my-nginx
      - docker run --name my-nginx -d -p 8080:80 nginx
      - http://localhost:8080 에서 nginx index.html 확인
    - 컨테이너 접근
      - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
      - docker exec -i -t  my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - curl localhost
        - exit
    - 컨테이너 삭제
      - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
      - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
  - Lab. Docker Build & Push
    - Dockerfile 로부터 이미지 생성
      - Dockerfile & 리소스 생성
        - mkdir Dockerfile
        - cd Dockerfile
        - nano index.html
          "Hi~ My name is Park Yong Joo.."
        - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
        - nano Dockerfile
          "FROM nginx
          COPY index.html /usr/share/nginx/html/"
        - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
      - 도커라이징 & Docker Hub에 Push
        - docker build -t (Docker-ID)/my-nginx . 
        - docker images
        - docker push (Docker-ID)/my-nginx
          "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
      - http://hub.docker.com 에서 이미지 확인
      - Docker Hub 이미지로부터 컨테이너 실행
        - docker run --name new-nginx -d -p 8081:80 (Docker-ID)/my-nginx
      - Browser에서 실행 애플리케이션 확인
        - http://localhost:8081
  - Clear
    - docker container rm $(docker ps -a -q)
      - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
      - docker container stop new-nginx
    - docker image rm -f $(docker images -q)
    
</details> 

### Kubernetes

<details>
<summary><b>Kubernetes Hands-on</b></summary>

- Lab에 필요한 리소스 내려받기
  - git clone https://github.com/event-storming/container-orchestration.git
  - cd container-orchestration
  - cd yaml
- Lab. K8s Sample App 생성
  - 어플리케이션 생성/ 확인
    - kubectl create -f azure-vote-samle.yaml
      "python / Flask, redis"
    - kubectl get all
  - 서비스 접속하기
    - kubectl get svc의 EXTERNAL-IP 복사
    - Browser에서 EXTERNAL-IP:80 접속
- Lab. Pod & 기본명령
  - kubectl get nodes
    - 쿠버네티스에 제대로 접속했는지 확인
    - 현 클러스터의 워크노드를 리스트업
    - 접속 결과 안나오는 경우
      - kubectl config current-context 명령으로 Cluster 접속 확인
  - 객체의 검색
    - kubectl get [object type]
    - kubectl get pods   # pods = pod = po
    - kubectl get deployments   # deploy
    - kubectl get services    # svc
    - kubectl get replicaset    # rs
  - 객체의 모니터링
    - watch kubectl get all
    - kubectl get pod -w
    - watch kubectl get pod
  - 객체의 유형
    - Service 
      - types
        - LoadBalancer
          - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
          - front-end 혹은 ingress (api gateway)
        - ClusterIP(default) / NodePort
          - 클러스터 내부 IP
          - 내부 마이크로 서비스
    - Deployment
      - ReplicaSet (하나이상 생성)
        - Pod (하나이상 생성)
          - Container (docker ) 하나이상.
    - Pod
    - ReplicaSet
    - Ingress
    - Secret
    - ConfigMap
    - ServiceAccount = sa
    - statefulset
    - daemonset
  - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
    - nano declarative-pod.yaml
      "apiVersion: v1
      kind: Pod
      metadata:
        name: declarative-pod
        labels:
          env: test
      spec:
        containers:
        - name: my-first-
          image: nginx"
    - 저장 및 종료 (ctrl + X, Y, 엔터)
    - kubectl create -f declarative-pod.yaml
    - kubectl get pods
  - 원하는 Node 타입에 Pod 생성
    - pwd 명령으로 현 위치가 /container-orchestration/yaml/pod 인지 확인
    - kubectl create -f pod-with-nodeselector.yaml
    - kubectl get po -o wide
      - Pod가 찾는 노드가 없어 pending 상태
    - 노드에 라벨 추가
      - kubectl label nodes [your-node-name] disktype=ssd
      - kubectl get nodes --show-labels | grep ssd
    - kubectl get po -o wide
  - 생성된 Pod 및 오브젝트 삭제
    - kubectl delete pod [pod명]
    - kubectl delete service,deploy --all
- Lab. Label 
  - kubectl run nginx --image=nginx
  - kubectl get pods -l app=nginx
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
- Lab. ReplicaSet
  - pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인
  - kubectl create -f replicaset.yaml
  - kubectl get all
  - replica 개수 조정
    - kubectl scale replicaset/frontend --replicas=5
    - kubectl get po 
- Lab. Deployment & 기본명령 
  - 기본 nginx 서버의 배포
  - kubectl create deploy nginx --image=nginx
  - kubectl get deploy nginx
  - kubectl get replicaset -l app=nginx
  - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
  - kubectl describe po (검색한 pod name)
  - (pod 제거)
  - kubectl delete po --all   # 
  - (pod 를 제거해도 재생됨을 확인)
  - kubectl get po
  - (scale out)
  - kubectl scale deploy nginx --replicas=3
  - kubectl get po   # pod 개수가 3개로 늘어남을 확인
  - kubectl delete po --all   # pod 를 모두 지움
  - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
  - ( 제거하기 위해서는 deployment 를 제거해야만 함)
  - kubectl delete deploy nginx
- Lab. Rollout & Back
  - (pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)
  - kubectl create -f nginx.yaml
  - (배포주석 확인, 주석이 없을 경우 아래 명령으로 주석 추가( Rollback시, 필요) ) 
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
  - (설정의 변경)
  - 파일을 편집기에서 열어(nano nginx.yaml) spec > replicas 부분을 3-->5 로 수정
  - kubectl apply -f nginx.yaml
  - (스케일 아웃 결과 확인)
  - kubectl get deploy     # DESIRED :3 --> 5 로 수정되고 곧 ACTIVE 도 5가 됨
  - (무정지 버전업)
  - 파일을 편집기에 열어서(nano nginx.yaml) spec > template > image 부분을 nginx:1.7.9 -> nginx:1.9.1 로 수정
  - kubectl apply -f nginx.yaml
  - (배포주석 달기)
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is nginx:1.9.1'
  - (결과확인)
  - kubectl describe po [해당 deployment 의 pod 중 하나의 이름]    # 내용의 image 부분이 1.791 인지 확인
  - (무정지 재배포 히스토리 확인)
  - kubectl rollout history deploy nginx-deployment
  - (다음과 같이 출력됨을 확인)
    "REVISION  CHANGE-CAUSE
    1         v1 is nginx:1.7.9
    2         v2 is nginx:1.9.1"
  - (롤백하기)
  - kubectl rollout undo deploy nginx-deployment
  - kubectl rollout undo deployment nginx --to-revision 1
- Lab. Service
  - kubectl delete service,deploy --all  # 기존 이력 삭제 
  - (다시 생성)
  - kubectl create deploy nginx --image=nginx
  - (서비스로 노출)
  -  kubectl expose deploy nginx --type="LoadBalancer" --port=80
  - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
  - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
- Auto Scale-Out 
  - pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인
  - (모든 객체 지우기)
  - kubectl delete deploy,service --all
  - (nginx 배포)
  - kubectl create deploy nginx --image=nginx
  - kubectl expose deploy nginx --type=LoadBalancer --port=80
  - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
    - kubectl autoscale deploy nginx --min=2 --max=10 --cpu-percent=15
    - kubectl get hpa nginx -o yaml
  - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
    - cat siege.yaml
    - kubectl create -f siege.yaml
    - kubectl exec -it siege -- /bin/bash
  - 로드 생성
    - siege -c50 -t30S http://(nginx ClusterIP Port)
- Lab. Volume
  - (pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)
  - (emptyDir 마운트)
  - kubectl create -f volume-emptydir.yaml
    - kubectl exec -it shared-volumes --container redis -- /bin/bash
    - cd /data/shared
    - echo test… > test.txt
    - exit
    - kubectl exec -it shared-volumes --container nginx -- /bin/bash
    - cd /data/shared
    - ls
  - (GitRepository를 볼륨으로 마운트)
  - kubectl create -f volume-gitrepo.yaml
  - (PersistentVolumeClaim 생성)
  - kubectl create -f volume-pvc.yaml
  - kubectl get pvc 
  - kubectl describe pvc azure-managed-disk
  - (생성된 PersistentVolueClaim으로 Pod 생성하기)
  - kubectl create -f pod-with-pvc.yaml
  - kubectl describe pod mypod
  - (포드 접속)
  - kubectl exec -it mypod -- /bin/bash
  - (마운트 및 사이즈 확인)
  - df -k
- Lab. ConfigMap
  - (pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)
  - (컨피그 맵 생성)
  - kubectl create configmap hello-cm --from-literal=language=java
  - kubectl get cm
  - kubectl get cm hello-cm -o yaml
  - 클라우드에서 배포 이미지 확인
  - nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)
  - (배포 및 서비스 생성)
    - kubectl create -f cm-deployment.yaml
    - kubectl create -f cm-service.yaml
  - (서비스 확인)
    - Service의 External-IP 접속
- Lab. Secret
  - (pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)
  - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
- Lab. Liveness & Readiness Probe
  - (pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)
  - (Liveness Command Probe 실습)
    - kubectl create -f exec-liveness.yaml 
    - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-exec
  - (Liveness HTTP Probe 실습)
    - kubectl create -f http-liveness.yaml
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-http
  - (Liveness 와 readiness probe 동시 적용 실습)
    - kubectl create -f tcp-liveness-readiness.yaml
    - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
    - kubectl describe po goproxy
- Lab. Ingress
  - Helm(패키지 인스톨러) 설치
    - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
    - (설치 중, sudo를 위한 비밀번호 입력) 
    - (Helm 초기화 설정)
      - (Helm 설치 관리자를 위한 시스템 사용자 생성)
      - kubectl --namespace kube-system create sa tiller 
      - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
      - (kubectl config current-context 명령으로 클러스터명 확인)
      - (helm version 3.x 이상에서는 init 불필요)
      - (helm version 2.x under Only) helm init --kube-context (나의 Azure 클러스터 명) --service-account tiller
      - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
      - helm repo update
  - Helm으로 Ingress Controller 설치
    - kubectl create namespace ingress-basic
    - (helm version 3.x 이상에서는 --name 옵션 불필요)
    - (helm version 2.x under) helm install --name nginx-ingress stable/nginx-ingress --kube-context=(MyAKSCluster) --namespace=ingress-basic
    - (helm version 3.x higher) helm install  nginx-ingress stable/nginx-ingress --namespace=ingress-basic
    - (설치확인)
      - kubectl get all --namespace=ingress-basic
      - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
  - Ingress 대상 서비스(BLUE, GREEN) 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-blue-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-blue-deployment.yaml  
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-green-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-green-deployment.yaml 
    - (서비스 생성 확인)
      - kubectl get deploy,service -n ingress-basic
  - Ingress 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)
    - kubectl create -f web-ingress.yaml
    - (Ingress 생성확인)
    - kubectl get ingress -n ingress-basic
  - Ingress 테스트
    - API Gateway 주소를 Local 시스템에 등록
      - 관리자권한으로 CMD 실행
      - cd c:\
      - cd windows
      - cd system32
      - cd drivers
      - cd etc
      - notepad hosts
      - Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록   
        "예시. 51.243.10.185	 blue.example.com  green.example.com"
    - 인그레이스 리소스 삭제
    - kubectl delete namespace ingress-basic

</details>

<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary> 

  - 사전 작업 : AWS의 EKS Node 개수 조정(4/4) 필요 
  - Lab. Istio 설치
    - (Istio 설치)
    - curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.4.5 sh -
    - cd istio-1.4.5
    - export PATH=$PWD/bin:$PATH
    - for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done
    - kubectl apply -f install/kubernetes/istio-demo.yaml
    - (설치확인)
    - kubectl get pod -n istio-system
    
  - Lab. Istio Tutorial 셋업
    - 서비스 메시 시나리오 : 사용자 선호도에 따른 추천서비스(v1, v2)로 운영자가 설정한 가중치에 따라, 스마트 라우팅(Canary) 되는 모형을 도구를 통해 함께 모니터링
    - (Git repository에서 Tutorial 리소스 가져오기)
      - cd ~
      - mkdir git
      - cd git
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - (네임스페이스 생성)
      - kubectl create namespace tutorial
    - (Customer 애플리케이션 배포)
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
    - (배포 확인 및 외부접속 설정)
      - kubectl -n tutorial edit svc customer
      - (ServiceType : ClusterIP -> LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl -n tutorial get svc
    - (customer 서비스의 EXTERNAL-IP 확인, 브라우저로 EXTERNAL-IP:8080 접속)
    - (테스트 애플리케이션 배포: Rreference, Recommendation-v1)
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
    - 서비스 메시 모니터링 및 추적시스템의 외부접속 환경설정
      - kubectl edit svc jaeger-query -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl edit svc kiali -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl get svc -n istio-system
      - 분산추적 시스템(Jaeger) 접속 : EXTERNAL-IP :16686
      - 모니터링 시스템(Kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
  - Lab. Istio 심플 라우팅
    - (Istio의 Simple Routing 확인)
    - (recommendation 서비스 추가 배포: v2)
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
    - (Recommendation v.2 서비스 Scale Out)
    - (서비스의 v2 의 replica 를 2로 설정)
      - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
      - kubectl get po -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
  - Lab. Istio 스마트 라우팅
    - 정책(VirtualService, DestinationRule) 설정
      - (현, 정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
      - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
        - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
      - (설정정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (서비스 확인)
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
        - Kiali(Externl-IP:20001), Jaeger(16686)에서 모니터링
    - 가중치 기반 스마트 라우팅
      - (recommendation 서비스 v1의 가중치를 100으로 변경)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
      - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
        - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - Canary 라우팅 비율별 배포 정책 예시
        - (90 : 10)
        - kubectl create -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
        - (75 : 25)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
        - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
    - Client 브라우저 유형별 스마트 라우팅
      - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
        - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
      - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
      - (Browser 환경이 지원되지 않을 경우,)
        - curl -A Safari Externl-IP:8080
        - curl -A Firefox Externl-IP:8080
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
  - Istio 테스트 Object 삭제
    - kubectl delete namespace tutorial
    - kubectl delete namespace istio-system

</details>
        
</p>
</details>

<hr />


### 마이크로소프트 Azure
<details>
<summary>Azure Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>


<details>
<summary><b>자주 사용되는 Cloud Commands</b></summary>

  - Cloud Configuration
    - az login
    
  - Azure 클러스터 생성
    - az aks create --resource-group user01_resource_group --name user01_cluster --node-count 3 --enable-addons monitoring --generate-ssh-keys
    
  - Azure 클러스터 토큰 가져오기
    - az aks get-credentials --resource-group (user01_resource_group) --name (user01_cluster)
  - Azure 컨테이너 레지스트리 생성
    - az acr create --resource-group (user01_resource_group) --name (user01_registry) --sku Basic
  - Azure 컨테이너 레지스트리 로그인
    - az acr login --name (user01_registry) --expose-token
  - Azure 클러스터에 레지스트리 붙이기
    - az aks update -n (user01_cluster) -g (user01_resource_group) --attach-acr (user01_registry)
  - Azure 레지스트리에 도커 이미지 푸시하기
    - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/[이미지명]:latest .
    
</details>    
    
### Docker

<details>
<summary><b>Setup</b></summary>    

- 관리자 권한으로 PowerShell 실행
  - Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
- 리눅스설치 및 실행
  - (설치전 확인 사항)
    - Windows 기능 켜기/끄기에서 'Linux용 Windows 하위시스템 활성화' 확인
    - 개발자 기능사용에서 '개발자 모드' 활성화 확인
  - Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
    - sudo vi /etc/apt/sources.list
    - :%s/archive.ubuntu.com/ftp.daumkakao.com/g
    - :wq!
    - sudo apt-get update
- Linux에 JDK 설치
  - (설치 명령)
  - sudo apt-get update
  - sudo apt install default-jdk
  - (bash에 환경변수 추가)
  -  cd ~
  - nano .bashrc
  - (맨아래로 이동)
  - (JAVA_HOME 설정 및 실행 Path 추가)
    "export JAVA_HOME=‘/usr/lib/jvm/java-11-openjdk-amd64
    export PATH=$PATH:$JAVA_HOME/bin:."
  - (수정사항 반영)
    - ctrl + x, y 입력, 종료
    - source ~/.bashrc
  - (설치 확인)
  - echo $JAVA_HOME
  - java -version
- Windows에 도커 데몬 설치
  - https://www.docker.com/products/docker-desktop
- 도커허브 계정생성
  -  http://hub.docker.com 접속 후, Sign Up (회원가입)
- 리눅스에 도커 Client 설치
  - sudo apt-get update
  - 비밀번호 입력창에 skadmin1234
  - sudo apt install apt-transport-https ca-certificates curl software-properties-common
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add 
  - sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
  - sudo apt update
  - sudo apt install docker-ce
  - 리눅스 설치시 생성한 사용자 명 입력
  - sudo usermod -aG docker skadmin
- 도커 데몬과 도커 Client 연결 
  - cd
  - nano .bashrc
  - 맨아래 줄에 아래 환경변수 추가
    - 방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력
    - export DOCKER_HOST=tcp://0.0.0.0:2375 
    - 저장 & 종료 : Ctrl + x, 입력 후, y 입력  후 엔터
  - source ~/.bashrc
  - 연결 확인
    - docker images
    - docker run --name nginx -d -p 80:80 nginx
    - docker images
</details> 

 <details>
<summary><b>Docker Hands-On</b></summary>
    
- Lab. image
  - 이미지 Pull
    - docker pull hello-world
    - docker images 
    - docker pull nginx
    - docker pull nginx:latest
    - docker pull docker.io/library/nginx:latest
    - docker pull nginx:1.16.1
    - docker images
  - 도커허브 (Docker Hub) 
    - http://hub.docker.com # 접속 후, nginx 검색 
  - 이미지 Tagging
    - docker image tag nginx my-nginx # Create 태그
  - 이미지 삭제
    - docker image rm my-nginx
    - docker image rm hello-world
    - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
- Lab. container
  - 컨테이너 생성
    - docker run hello-world # 컨테이너 만들기
    - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
    - docker run --name my-nginx -d -p 80:80 nginx
    - docker ps
  - 컨테이너 시작/종료
    - docker stop my-nginx
    - docker start my-nginx
  - 컨테이너 포트 노출
    - http://localhost 에서 nginx index.html 확인
    - docker container rm my-nginx
    - docker run --name my-nginx -d -p 8080:80 nginx
    - http://localhost:8080 에서 nginx index.html 확인
  - 컨테이너 접근
    - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
    - docker exec -i -t  my-nginx /bin/bash
      - apt-get update
      - apt-get install curl
      - curl localhost
      - exit
  - 컨테이너 삭제
    - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
    - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
- Lab. Docker Build & Push
  - Dockerfile로부터 이미지 생성
    - Dockerfile & 리소스 생성
      - mkdir Dockerfile
      - cd Dockerfile
      - nano index.html
        "Hi~ My name is Park Yong Joo.."
      - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
      - nano Dockerfile
        "FROM nginx
        COPY index.html /usr/share/nginx/html/"
      - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
    - 도커라이징 & Push
      - docker build -t (Docker-ID)/my-nginx . 
      - docker images
      - docker push (Docker-ID)/my-nginx
        "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
    - http://hub.docker.com 에서 이미지 확인
    - Docker Hub 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 (Docker-ID)/my-nginx
    - Browser에서 실행 애플리케이션 확인
      - http://localhost:8080
- Clear
  - docker container rm $(docker ps -a -q)
    - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
    - docker container stop new-nginx
  - docker image rm -f $(docker images -q)

</details>  
  
### Kubernetes 

 <details>
<summary><b>Cloud Client Setup</b></summary>

  - Cloud Shell 에서 Setup 확인 명령
      - az aks get-credentials --resource-group My_Resource_Group --name My-cluster
      - kubectl config current-context
      
  - Cloud Client Setup
    - Kubectl 설치 (ubuntu 18.04)
      - sudo apt-get update && sudo apt-get install -y apt-transport-https
      - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
      - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
      - sudo apt-get update
      - sudo apt-get install -y kubectl
    - Azure-Cli 설치
      - curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
      - az login
    - Local에 AKS(Azure Kubernetes Service) 클러스터 접속정보 설정
      - az aks get-credentials --resource-group [azure-resource-name] --name [azure-cluster-name]
      - kubectl config current-context
      - kubectl get all
    - Local에 ACR(Azure Container Registry) 접속정보 설정
      - az acr login --name [azure-registry-name]
    - Azure AKS와 ACR 연결 (4')
      - az aks update -n [azure-cluster-name] -g [azure-resource-Group-name] --attach-acr [azure-acr-name]

</details>      

<details>
<summary><b>Kubernetes Hands-on</b></summary>

 - Lab에 필요한 리소스 내려받기
    - git clone https://github.com/event-storming/container-orchestration.git
    - cd container-orchestration
    - cd yaml
    
- Lab. K8s Sample App 생성
  - 어플리케이션 생성/ 확인
    - kubectl create -f azure-vote-samle.yaml
      "python / Flask, redis"
    - kubectl get all
  - 서비스 접속하기
    - kubectl get svc의 EXTERNAL-IP 복사
    - Browser에서 EXTERNAL-IP:80 접속
- Lab. Pod & 기본명령
  - kubectl get nodes
    - 쿠버네티스에 제대로 접속했는지 확인
    - 현 클러스터의 워크노드를 리스트업
    - 접속 결과 안나오는 경우
      - kubectl config current-context 명령으로 Cluster 접속 확인
  - 객체의 검색
    - kubectl get [object type]
    - kubectl get pods   # pods = pod = po
    - kubectl get deployments   # deploy
    - kubectl get services    # svc
    - kubectl get replicaset    # rs
  - 객체의 모니터링
    - watch kubectl get all
    - kubectl get pod -w
    - watch kubectl get pod
  - 객체의 유형
    - Service 
      - types
        - LoadBalancer
          - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
          - front-end 혹은 ingress (api gateway)
        - ClusterIP(default) / NodePort
          - 클러스터 내부 IP
          - 내부 마이크로 서비스
    - Deployment
      - ReplicaSet (하나이상 생성)
        - Pod (하나이상 생성)
          - Container (docker ) 하나이상.
    - Pod
    - ReplicaSet
    - Ingress
    - Secret
    - ConfigMap
    - ServiceAccount = sa
    - statefulset
    - daemonset
  - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
    - nano declarative-pod.yaml
      "apiVersion: v1
      kind: Pod
      metadata:
        name: declarative-pod
        labels:
          env: test
      spec:
        containers:
        - name: memory-demo-ctr
          image: nginx"
    - 저장 및 종료 (ctrl + X, Y, 엔터)
    - kubectl create -f declarative-pod.yaml
    - kubectl get pods
  - 원하는 Node 타입에 Pod 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/pod 인지 확인)
    - kubectl create -f pod-with-nodeselector.yaml
    - kubectl get po -o wide
      - Pod가 찾는 노드가 없어 pending 상태
    - 노드에 라벨 추가
      - kubectl label nodes [your-node-name] disktype=ssd
      - kubectl get nodes --show-labels | grep ssd
    - kubectl get po -o wide
  - Pod 생성 전 초기화  
    - kubectl create -f pod-initialize.yaml
    - kubectl get po
    - (생성된 Pod 내로 접근)
    - kubectl exec -it init-demo -- /bin/bash 
    - cd /usr/share/nginx/html
    - ls
  - 생성된 Pod 및 오브젝트 삭제
    - kubectl delete pod [pod명]
    - kubectl delete service,deploy --all
- Lab. Label 
  - kubectl run nginx --image=nginx
  - kubectl get pods -l run=nginx
  - kubectl get pods --selector run=nginx
  - kubectl get pods --selector 'run in (nginx, test)'
- Lab. ReplicaSet
  - pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인
  - kubectl create -f replicaset.yaml
  - kubectl get all
  - (replica 개수 조정)
    - kubectl scale replicaset/frontend --replicas=5
    - kubectl get po 
- Lab. Deployment & 기본명령 
  - 기본 nginx 서버의 배포
  - kubectl create deploy nginx --image=nginx
  - kubectl get deploy nginx
  - kubectl get replicaset -l app=nginx
  - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
  - kubectl describe po (검색한 pod name)
  - (pod 제거)
  - kubectl delete po --all   # 
  - (pod 를 제거해도 재생됨을 확인)
  - kubectl get po
  - (scale out)
  - kubectl scale deploy nginx --replicas=3
  - kubectl get po   # pod 개수가 3개로 늘어남을 확인
  - kubectl delete po --all   # pod 를 모두 지움
  - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
  - ( 제거하기 위해서는 deployment 를 제거해야만 함)
  - kubectl delete deploy nginx
- Lab. Rollout & Back
  - (pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)
  - kubectl create -f nginx.yaml
  - (아래 명령으로 배포 주석 추가, Rollback시 필요) 
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
  - Set image 명령을 통한 이미지 Rollout  및 확인
  - kubectl set image deploy nginx-deployment nginx=nginx:1.9.1
  - kubectl rollout history deploy nginx-deployment
  - (배포주석 달기)
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is nginx:1.9.1'
  - kubectl describe po [해당 deployment 의 pod 중 하나의 이름]    # 내용의 image 부분이 1.9.1 인지 확인
  - (무정지 재배포 히스토리 확인)
  - kubectl rollout history deploy nginx-deployment
  - (다음과 같이 출력됨을 확인)
    "REVISION  CHANGE-CAUSE
    1         v1 is nginx:1.7.9
    2         v2 is nginx:1.9.1"
  - (롤백하기)
  - kubectl rollout undo deploy nginx-deployment
  - kubectl rollout undo deploy nginx-deployment --to-revision 1
- Lab. Service
  - kubectl delete service,deploy --all  # 기존 이력 삭제 
  - (다시 생성)
  - kubectl create deploy nginx --image=nginx
  - (서비스로 노출)
  -  kubectl expose deploy nginx --type="LoadBalancer" --port=80
  - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
  - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
- Auto Scale-Out 
  - pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인
  - (모든 객체 지우기)
  - kubectl delete deploy,service --all
  - (대상 서비스 배포 및 모니터링-watch)
  - kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
  - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
    - kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10
    - kubectl get hpa php-apache -o yaml
  - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
    - cat siege.yaml
    - kubectl create -f siege.yaml
    - kubectl exec -it siege -- /bin/bash
  - 로드 생성
    - siege -c30 -t30S -v http://php-apache
- Lab. Volume
  - (pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)
  - (emptyDir 마운트)
  - kubectl create -f volume-emptydir.yaml
  - (GitRepository를 볼륨으로 마운트)
  - kubectl create -f volume-gitrepo.yaml
  - (PersistentVolumeClaim 생성)
  - kubectl create -f volume-pvc.yaml
  - kubectl get pvc 
  - kubectl describe pvc azure-managed-disk
  - (생성된 PersistentVolueClaim으로 Pod 생성하기)
  - kubectl create -f pod-with-pvc.yaml
  - kubectl describe pod mypod
  - (포드 접속)
  - kubectl exec -it mypod -- /bin/bash
  - (마운트 및 사이즈 확인)
  - df -k
- Lab. ConfigMap
  - (pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)
  - (컨피그 맵 생성)
  - kubectl create configmap hello-cm --from-literal=language=java
  - kubectl get cm
  - kubectl get cm hello-cm -o yaml
  - (도커라이징 & ACR Push)
    - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/cm-sandbox:v1 .
  - (인증오류 발생 시, ACR 로그인)
    - az acr login --name (Azure Container Registry 명) --expose-token
  - 클라우드에서 배포 이미지 확인
  - nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)
  - (배포 및 서비스 생성)
    - kubectl create -f cm-deployment.yaml
    - kubectl create -f cm-service.yaml
  - (서비스 확인)
    - Service의 External-IP 접속
- Lab. Secret
  - (pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)
  - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
- Lab. Liveness & Readiness Probe
  - (pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)
  - (Liveness Command Probe 실습)
    - kubectl create -f exec-liveness.yaml 
    - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-exec
  - (Liveness HTTP Probe 실습)
    - kubectl create -f http-liveness.yaml
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-http
  - (Liveness 와 readiness probe 동시 적용 실습)
    - kubectl create -f tcp-liveness-readiness.yaml
    - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
    - kubectl describe po goproxy
- Kubernetes Advanced Hands-on
- Lab. Ingress
  - Helm 명령으로 설치 여부 확인
  - Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
    - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
    - (설치 중, sudo를 위한 비밀번호 입력) 
    - kubectl --namespace kube-system create sa tiller 
    - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
    - helm init --service-account tiller
  - Helm으로 Ingress Controller 설치
    - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    - helm repo update
    - kubectl create namespace ingress-basic
    - helm version으로 버전확인
    - (helm version 2.x) helm install --name nginx-ingress stable/nginx-ingress --kube-context=(MyAKSCluster) --namespace=ingress-basic
    - (helm version 3.x) helm install  nginx-ingress stable/nginx-ingress --namespace=ingress-basic
    - (설치확인)
      - kubectl get all --namespace=ingress-basic
      - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
  - Ingress 대상 서비스(BLUE, GREEN) 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-blue-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-blue-deployment.yaml  
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-green-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-green-deployment.yaml 
    - (서비스 생성 확인)
      - kubectl get deploy,service -n ingress-basic
  - Ingress 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)
    - kubectl create -f web-ingress.yaml
    - (Ingress 생성확인)
    - kubectl get ingress -n ingress-basic
  - Ingress 테스트
    - API Gateway 주소를 Local 시스템에 등록
      - 관리자권한으로 CMD 실행
      - cd c:\
      - cd windows
      - cd system32
      - cd drivers
      - cd etc
      - notepad hosts
      - Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록   
        "예시. 51.243.10.185	 blue.example.com  green.example.com"
    - 인그레이스 리소스 삭제
    - kubectl delete namespace ingress-basic

 </details>
         
 <details>
<summary><b>Real MSA Application Deployment</b></summary>

  - 사전작업
    - az acr login --name [acr-repository-name] --expose-token
    - cd  ~
    - mkdir MSA-Sample
    - cd MSA-Sample
    
  - 마이크로서비스 배포
    - 상품(Product) 서비스 
      "git clone https://github.com/event-storming/reqres_products.git
      cd reqres_products
      
      mvn package -Dmaven.test.skip=true
      
      az acr build --registry (myregistry) --image (myregistry).azurecr.io/products:latest .
      
      kubectl create deploy products --image=(myregistry).azurecr.io/products:latest
      kubectl expose deploy products --type="ClusterIP" --port=8080
      
      cd .."
    - 여러 서비스를 편하게 배포하기 위해 Container Registry를 환경변수로 설정
      - export CRNAME=(myregistry)
      - export ACR=${CRNAME}.azurecr.io
    - 주문(Order) 서비스 
      "git clone https://github.com/event-storming/reqres_orders.git
      cd reqres_orders
      export IMAGENAME=orders
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 배송(Delivery) 서비스
      "git clone https://github.com/event-storming/reqres_delivery.git
      cd reqres_delivery
      export IMAGENAME=delivery
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 인증(Oauth) 서비스 
      "git clone https://github.com/event-storming/oauth.git
      cd oauth
      export IMAGENAME=oauth
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 게이트웨이(Gateway) 서비스
      "git clone https://github.com/event-storming/gateway.git
      cd gateway
      export IMAGENAME=gateway
      
      mvn package -Dmaven.test.skip=true
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      kubectl create deploy ${IMAGENAME} --image=${ACR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
    - 프론트-엔드(UI) 서비스 빌드를 위한 npm 설치 (Azure Cloud에서 실행시 Skip)
      "sudo apt-get update
      sudo apt install build-essential
      curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
      sudo apt install nodejs
      "
    - 프론트-엔드(UI) 서비스: 배포 사전 작업
      "git clone https://github.com/event-storming/ui.git
      cd ui
      export IMAGENAME=ui
      
      npm install
      npm run build
      az acr build --registry ${CRNAME} --image ${ACR}/${IMAGENAME}:latest .
      
      _GATEWAY_IP=$(kubectl get -o jsonpath="{.status.loadBalancer.ingress[0].ip}" svc gateway --ignore-not-found)
      echo ${_GATEWAY_IP}
      "
    - 프론트-엔드(UI) 서비스:  배포 및 서비스 생성
      "cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${IMAGENAME}
        labels:
          app: ${IMAGENAME}
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ${IMAGENAME}
        template:
          metadata:
            labels:
              app: ${IMAGENAME}
          spec:
            containers:
              - name: ${IMAGENAME}
                image: ${ACR}/${IMAGENAME}:latest
                ports:
                  - containerPort: 8080
                env:
                  - name: VUE_APP_API_HOST
                    value: http://${_GATEWAY_IP}:8080
      EOF
      
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
  - 서비스 확인
    - kubectl get svc ui
    - 브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080
    
 </details>
         
 <details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>

  - Lab. Istio 설치
    - (Istio 설치)
    - curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.4.5 sh -
    - cd istio-1.4.5
    - export PATH=$PWD/bin:$PATH
    - for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done
    - kubectl apply -f install/kubernetes/istio-demo.yaml
    - (설치확인)
    - kubectl get pod -n istio-system
    
  - Lab. Istio Tutorial 셋업
    - 서비스 메시 시나리오 : 
      - 사용자 선호도에 따른 추천서비스(v1, v2)로 운영자가 설정한 라우팅 정책에 따라, 스마트 라우팅(Canary) 되는 모형을 도구를 통해 함께 모니터링
    - (Git repository에서 Tutorial 리소스 가져오기)
      - cd ~
      - mkdir git
      - cd git
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - (네임스페이스 생성)
      - kubectl create namespace tutorial
    - (Customer 애플리케이션 배포)
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
    - (배포 확인 및 외부접속 설정)
      - kubectl -n tutorial edit service customer
      - (ServiceType : ClusterIP -> LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :%s/LoadBalancer/ClusterIP/g
        - :wq!
      - kubectl -n tutorial get svc
    - (customer 서비스의 EXTERNAL-IP 확인, 브라우저로 EXTERNAL-IP:8080 접속)
    - (테스트 애플리케이션 배포: Rreference, Recommendation-v1)
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
    - 서비스 메시 모니터링 및 추적시스템의 외부접속 환경설정
      - kubectl edit svc jaeger-query -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl edit svc kiali -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl get svc -n istio-system
      - 분산추적 시스템(Jaeger) 접속 : EXTERNAL-IP :16686
      - 모니터링 시스템(Kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
  - Lab. Istio 심플 라우팅
    - (Istio의 Simple Routing 확인)
    - (recommendation 서비스 추가 배포: v2)
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
    - (Recommendation v.2 서비스 Scale Out)
    - (서비스의 v2 의 replica 를 2로 설정)
      - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
      - kubectl get po -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
  - Lab. Istio 스마트 라우팅
    - 정책(VirtualService, DestinationRule) 설정
      - (현, 정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
      - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
        - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
      - (설정정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (서비스 확인)
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
        - Kiali(Externl-IP:20001), Jaeger(16686)에서 모니터링
    - 가중치 기반 스마트 라우팅
      - (recommendation 서비스 v1의 가중치를 100으로 변경)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
      - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
        - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - Canary 라우팅 비율별 배포 정책 예시
        - (90 : 10)
        - kubectl create -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
        - (75 : 25)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
        - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
    - Client 브라우저 유형별 스마트 라우팅
      - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
        - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
      - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
      - (Browser 환경이 지원되지 않을 경우,)
        - curl -A Safari Externl-IP:8080
        - curl -A Firefox Externl-IP:8080
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
  - Istio 테스트 Object 삭제
    - kubectl delete namespace tutorial
    - kubectl delete namespace istio-system
    
 </details>
         
 <details>
<summary><b>Back-up</b></summary>

  - Container로부터 이미지 생성
    - 이미지 생성
      - docker run --name my-nginx -d -p 80:80 nginx
      - docker exec -it my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - cd /usr/share/nginx/html
        - echo 'Hello my name is PYJ.' >> index.html
        - exit
      - docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성
      - docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인
      - docker commit -a "apex@naver.com" -m "update nginx" my-nginx my-nginx:1.0 
      - docker images
      - docker stop my-nginx
      - docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0
      - http://localhost 확인
      - docker stop my-nginx2
      
    - 이미지 푸시
      - docker tag my-nginx:1.0 apexacme/my-nginx:1.0
      - docker images
      - docker push apexacme/my-nginx:1.0
      - http://hub.docker.com 에서 이미지 확인
    - 도커허브 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0
  - 샘플 자바 애플리케이션 패키징과 배포 
    - (pwd 로 현 위치가 /container-orchestration/ 인지 확인)
    - git clone https://github.com/event-storming/monolith.git
    - cd monolith/
    - ls
    - (skip) mvn spring-boot:run #Maven으로 App. 실행 
    - mvn package -B -Dmaven.test.skip=true
    - (skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행
    - cat Dockerfile # 도커파일 내용 확인
    - (도커라이징)
      - docker build -t (Azure container registry명).azurecr.io/monolith:v1 .     
        - 주의1 :   명령  맨끝에 " ." 빼먹으면 안됨.   Dockerfile 의 위치인
        - 주의2 :   project id 부분을 자신의 GCP project id 로 변경!!
        - 주의3 :   현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함
      - docker images
      - (skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행
      - docker push (azure container registry명).azurecr.io/monolith:v1
    - kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1
    - kubectl get po -l app=monolith
    - kubectl expose deploy monolith --type="LoadBalancer" --port=8080
    - kubectl get svc -w
    - 자바 애플리케이션 접속
      - http://(Service_Extern-IP):8080
      
  - Lab. Istio Egress
    - 외부 도메인을 호출하는 v3 버전을 배포
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
    - v3에서 날짜정보가 추가로 출력됨을 확인
    - Istio 트래픽을 등록된 것만 허용하도록 변경
      - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인
    - 트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
      - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial
      - kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - 화면에 Error Log 출력 : “customer => Error: 503 - preference => Error: 500”
    - 외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
      - kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력
    - (테스트 후, 설정 복구)
    - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g' | kubectl replace -n istio-system -f -

</details>

</p>
</details>
<hr />


### 아마존 AWS
<details>
<summary>AWS Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>

<details>
<summary><b>자주 사용되는 Cloud Commands</b></summary>

  - Cloud Configuration
    - aws configure
    
  - AWS 클러스터 생성
    - eksctl create cluster --name (Cluster-Name) --version 1.15 --nodegroup-name standard-workers --node-type t3.medium --nodes 3 --nodes-min 1 --nodes-max 3
    
  - AWS 클러스터 토큰 가져오기
    - aws eks --region eu-west-3 update-kubeconfig --name user22-sk-Cluster
  - AWS 컨테이너 레지스트리 생성
    - aws ecr create-repository --repository-name (Registry_Name) --image-scanning-configuration scanOnPush=true --region ap-northeast-2
  - AWS 컨테이너 레지스트리 로그인
    - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com
  - AWS 레지스트리에 도커 이미지 푸시하기
    - aws ecr create-repository --repository-name (IMAGE_NAME) --region ap-northeast-2
    - docker push 283210891307.dkr.ecr.ap-northeast-2.amazonaws.com/(IMAGE_NAME):latest
</details>    
    
### Docker

<details>
<summary><b>Setup</b></summary>

- 관리자 권한으로 PowerShell 실행
  - Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux      
- 리눅스설치 및 실행
  - (설치전 확인 사항)
    - Windows 기능 켜기/끄기에서 'Linux용 Windows 하위시스템 활성화' 확인
    - 개발자 기능사용에서 '개발자 모드' 활성화 확인
  - Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
    - sudo vi /etc/apt/sources.list
    - :%s/archive.ubuntu.com/ftp.daumkakao.com/g
    - :wq!
    - sudo apt-get update
    
- Linux에 JDK 설치
  - (설치 명령)
  
  - sudo apt-get update
  - sudo apt install default-jdk
  - (bash에 환경변수 추가)
  -  cd ~
  - nano .bashrc
  - (맨아래로 이동)
  - (JAVA_HOME 설정 및 실행 Path 추가)
    export JAVA_HOME='/usr/lib/jvm/java-11-openjdk-amd64'
    export PATH=$PATH:$JAVA_HOME/bin:.
  - (수정사항 반영)
    - ctrl + x, y 입력, 종료 
    - source ~/.bashrc
  - (설치 확인)
  - echo $JAVA_HOME
  - java -version
- Windows에 도커 데몬 설치
  - https://www.docker.com/products/docker-desktop
- 도커허브 계정생성
  -  http://hub.docker.com 접속 후, Sign Up (회원가입)
- 리눅스에 도커 Client 설치
  - sudo apt-get update
  - 비밀번호 입력창에 skadmin1234
  - sudo apt install apt-transport-https ca-certificates curl software-properties-common
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add 
  - sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
  - sudo apt update
  - sudo apt install docker-ce
  - 리눅스 설치시 생성한 사용자 명 입력
  - sudo usermod -aG docker skccadmin
- 도커 데몬과 도커 Client 연결 
  - cd
  - nano .bashrc
  - 맨아래 줄에 아래 환경변수 추가
    - 방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력
    - export DOCKER_HOST=tcp://0.0.0.0:2375 
    - 저장 & 종료 : Ctrl + x, 입력 후, y 입력  후 엔터
  - source ~/.bashrc
  - 연결 확인
    - docker images
    - docker run --name nginx -d -p 80:80 nginx
    - docker images
</details>

<details>
<summary><b>Docker Hands-on</b></summary>   
 
- Lab. image

  - 이미지 Pull
    - docker pull hello-world
    - docker images 
    - docker pull nginx
    - docker pull nginx:latest
    - docker pull docker.io/library/nginx:latest
    - docker pull nginx:1.16.1
    - docker images
    
  - 도커허브 (Docker Hub) 
    - http://hub.docker.com # 접속 후, nginx 검색 
  - 이미지 Tagging
    - docker image tag nginx my-nginx # Create 태그
  - 이미지 삭제
    - docker image rm my-nginx
    - docker image rm hello-world
    - docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기
- Lab. container
  - 컨테이너 생성
    - docker run hello-world # 컨테이너 만들기
    - docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성
    - docker run --name my-nginx -d -p 80:80 nginx
    - docker ps
  - 컨테이너 시작/종료
    - docker stop my-nginx
    - docker start my-nginx
  - 컨테이너 포트 노출
    - http://localhost 에서 nginx index.html 확인
    - docker container rm my-nginx
    - docker run --name my-nginx -d -p 8080:80 nginx
    - http://localhost:8080 에서 nginx index.html 확인
  - 컨테이너 접근
    - docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근
    - docker exec -i -t  my-nginx /bin/bash
      - apt-get update
      - apt-get install curl
      - curl localhost
      - exit
  - 컨테이너 삭제
    - docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류
    - docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기
- Lab. Docker Build & Push
  - Dockerfile로부터 이미지 생성
    - Dockerfile & 리소스 생성
      - mkdir Dockerfile
      - cd Dockerfile
      - nano index.html
        "Hi~ My name is Park Yong Joo.."
      - 저장 및 종료 (Ctrl + X, y 입력 후 엔터)
      - nano Dockerfile
        "FROM nginx
        COPY index.html /usr/share/nginx/html/"
      - 저장 및 종료 (Ctrl + x, Y 입력 후 엔터)
    - 도커라이징 & Push
      - docker build -t Docker-ID/my-nginx:v1 . 
      - docker images
      - docker push Docker-ID/my-nginx:v1
        "denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다."
    - http://hub.docker.com 에서 이미지 확인
    - Docker Hub 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 Docker-ID/my-nginx:v1
    - Browser에서 실행 애플리케이션 확인
      - http://localhost:8080
- Clear
  - docker container rm $(docker ps -a -q)
    - container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.
    - docker container stop new-nginx
  - docker image rm -f $(docker images -q)
</details>

### Kubernetes   
    
<details>
<summary><b>Cloud Client Setup</b></summary> 
     
- Kubectl 설치 (ubuntu 18.04)
  - sudo apt-get update && sudo apt-get install -y apt-transport-https
  - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
  - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
  - sudo apt-get update
  - sudo apt-get install -y kubectl
  
- AWS-Cli v2 설치
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip awscliv2.zip
  - (unzip이 없을 경우, 설치)
    - sudo apt-get install unzip
  - sudo ./aws/install
- AWS Configure
  - (AWS 관리콘솔)
  - 1. 부여받은 교육 계정으로  AWS 콘솔 접속
  - 2. IAM 서비스 접속
  - 3. 왼쪽 메뉴에서 '엑세스 관리' > '사용자' 클릭
  - 4. 나의 계정정보 클릭
  - 5. 메인화면에서 '보안자격증명' 클릭
  - 6. '액세스 키 만들기' 클릭
  - 7. Access Key ID와 Secret Access key를 복사
  - (클라이언트 Tool)
  - aws configure 입력
  - 관리콘솔에 복사한 Access Key ID와 Secret Access key 입력
  - region 정보에 ap-northeast-2 입력
  - default output format에 json 입력
- EKS Client (eksctl) 설치
  - curl --location "https://github.com/weaveworks/eksctl/releases/download/latest_release/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
  - sudo mv /tmp/eksctl /usr/local/bin
- Amazon EKS 생성
  - eksctl create cluster --name user15-sk-Cluster --version 1.15 --nodegroup-name standard-workers --node-type t3.medium --nodes 3 --nodes-min 1 --nodes-max 3
- Local에 EKS 클러스터 접속정보 설정
  - aws eks --region ap-northeast-2 update-kubeconfig --name My-EKSCluster
  - kubectl config current-context
  - kubectl get all
- Local에 ECR(Elastic Container Registry) 인증 및 토큰 설정
  - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com

</details>

<details>
<summary><b>Kubernetes Hands-on</b></summary> 

- Lab에 필요한 리소스 내려받기
  - git clone https://github.com/event-storming/container-orchestration.git
  - cd container-orchestration
  - cd yaml_aws      
  
- Lab. K8s Sample App 생성
  - 어플리케이션 생성/ 확인
    - kubectl create -f azure-vote-samle.yaml
      "python / Flask, redis"
    - kubectl get all
  - 서비스 접속하기
    - kubectl get svc의 EXTERNAL-IP 복사
    - Browser에서 EXTERNAL-IP:80 접속
    
- Lab. Pod & 기본명령
  - kubectl get nodes
    - 쿠버네티스에 제대로 접속했는지 확인
    - 현 클러스터의 워크노드를 리스트업
    - 접속 결과 안나오는 경우
      - kubectl config current-context 명령으로 Cluster 접속 확인
  - 객체의 검색
    - kubectl get [object type]
    - kubectl get pods   # pods = pod = po
    - kubectl get deployments   # deploy
    - kubectl get services    # svc
    - kubectl get replicaset    # rs
  - 객체의 모니터링
    - watch kubectl get all
    - kubectl get pod -w
    - watch kubectl get pod
  - 객체의 유형
    - Service 
      - types
        - LoadBalancer
          - 클라우드 제공자에 의해 제공된 Loadbalancer 로 노출
          - front-end 혹은 ingress (api gateway)
        - ClusterIP(default) / NodePort
          - 클러스터 내부 IP
          - 내부 마이크로 서비스
    - Deployment
      - ReplicaSet (하나이상 생성)
        - Pod (하나이상 생성)
          - Container (docker ) 하나이상.
    - Pod
    - ReplicaSet
    - Ingress
    - Secret
    - ConfigMap
    - ServiceAccount = sa
    - statefulset
    - daemonset
  - 설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
    - nano declarative-pod.yaml
      "apiVersion: v1
      kind: Pod
      metadata:
        name: declarative-pod
        labels:
          env: test
      spec:
        containers:
        - name: memory-demo-ctr
          image: nginx"
    - 저장 및 종료 (ctrl + X, Y, 엔터)
    - kubectl create -f declarative-pod.yaml
    - kubectl get pods
  - 원하는 Node 타입에 Pod 생성
    - pwd 로 현 위치가 /container-orchestration/yaml_aws/pod 인지 확인
    - kubectl create -f pod-with-nodeselector.yaml
    - kubectl get po -o wide
      - Pod가 찾는 노드가 없어 pending 상태
    - 노드에 라벨 추가
      - kubectl label nodes <your-node-name> disktype=ssd
      - kubectl get nodes --show-labels | grep ssd
    - kubectl get po -o wide
  - Pod 생성 전 초기화  
    - kubectl create -f pod-initialize.yaml
    - kubectl get po
    - 생성된 Pod 내로 접근
    - kubectl exec -it init-demo -- /bin/bash 
    - cd /usr/share/nginx/html
    - ls
  - 생성된 Pod, 및 오브젝트 삭제
    - kubectl delete pod [pod명]
    - kubectl delete service,deploy --all

- Lab. Label 
  - 2개의 Pod 생성
  - (1. pod 폴더로 이동하여, 아래 명령어 실행)
  - kubectl create -f pod-with-nodeselector.yaml 
  - (2. 아래 nginx 컨테이너 생성)
  - kubectl run nginx2 --image=nginx
  - kubectl get pods -l run=nginx2
  - kubectl get pods --selector run=nginx2
  - kubectl get pods --selector 'run in (nginx2, test)'
- Lab. ReplicaSet
  - pwd 로 현 위치가 /container-orchestration/yaml_aws/replicaset 인지 확인
  - kubectl create -f replicaset.yaml
  - kubectl get all
  - replica 개수 조정
    - kubectl scale replicaset/frontend --replicas=5
    - kubectl get po 
- Lab. Deployment & 기본명령 
  - 기본 nginx 서버의 배포
  - kubectl create deploy nginx --image=nginx
  - kubectl get deploy nginx
  - kubectl get replicaset -l app=nginx
  - kubectl get po -l app=nginx  # "-l" 옵션은 label의 key/value 로 객체를 필터링
  - kubectl get pods --selector app=nginx
  - kubectl get pods --selector 'app in (nginx, test)'
  - kubectl describe po (검색한 pod name)
  - (pod 제거)
  - kubectl delete po --all   # 
  - (pod 를 제거해도 재생됨을 확인)
  - kubectl get po
  - (scale out)
  - kubectl scale deploy nginx --replicas=3
  - kubectl get po   # pod 개수가 3개로 늘어남을 확인
  - kubectl delete po --all   # pod 를 모두 지움
  - kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인
  - ( 제거하기 위해서는 deployment 를 제거해야만 함)
  - kubectl delete deploy nginx
- Lab. Rollout & Back
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인)
  - kubectl create -f nginx.yaml
  - (아래 명령으로 배포 주석 추가, Rollback시 필요) 
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v1 is nginx:1.7.9'
  - Set image 명령을 통한 이미지 Rollout  및 확인
  - kubectl set image deploy nginx-deployment nginx=nginx:1.9.1
  - kubectl rollout history deploy nginx-deployment
  - (배포주석 달기)
  - kubectl annotate deploy nginx-deployment kubernetes.io/change-cause='v2 is nginx:1.9.1'
  - kubectl describe po <해당 deployment 의 pod 중 하나의 이름>    # 내용의 image 부분이 1.9.1 인지 확인
  - (무정지 재배포 히스토리 확인)
  - kubectl rollout history deploy nginx-deployment
  - (다음과 같이 출력됨을 확인)
    "REVISION  CHANGE-CAUSE
    1         v1 is nginx:1.7.9
    2         v2 is nginx:1.9.1
  - (롤백하기)
  - kubectl rollout undo deploy nginx-deployment
  - kubectl rollout undo deploy nginx-deployment --to-revision 1
- Lab. Service
  - kubectl delete service,deploy --all  # 기존 이력 삭제 
  - (다시 생성)
  - kubectl create deploy nginx --image=nginx
  - (서비스로 노출)
  -  kubectl expose deploy nginx --type="LoadBalancer" --port=80
  - (웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)
  - kubectl exec -it (pod name) -- /bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근
- Auto Scale-Out 
  - pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인
  - (모든 객체 지우기)
  - kubectl delete deploy,service --all
  - (대상 서비스 배포 및 모니터링)
  - kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
  - (오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
    - kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10
    - kubectl get hpa php-apache -o yaml
  - 로드 제너레이터(siege)가 설치된 컨테이너 생성 
    - cat siege.yaml
    - kubectl create -f siege.yaml
    - kubectl exec -it siege -- /bin/bash
  - 로드 생성
    - siege -c30 -t30S -v http://php-apache
- Lab. Volume
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/volume 인지 확인)
  - (emptyDir 마운트)
  - kubectl create -f volume-emptydir.yaml
  - (GitRepository를 볼륨으로 마운트)
  - kubectl create -f volume-gitrepo.yaml
  - (EFS - Elastic File System 생성하기)
    - 관리콘솔에서 EFS 생성
    - EFS Service Account 생성 : efs-sa.yaml 실행
    - EFS Provisioner 배포 : 
      - 관리콘솔에서 생성한 efs ID와 DNS 정보로 수정 
      - nano efs-provisioner-deploy.yaml 
      - efs-provisioner-deploy.yaml 실행
    - SA 권한 설정 :  efs-rbac.yaml 실행
    - StorageClass 생성 :  efs-storageclass.yaml 실행
  - (PersistentVolumeClaim 생성)
  - kubectl create -f volume-pvc.yaml
  - kubectl get pvc 
  - kubectl describe pvc aws-efs
  - (생성된 PersistentVolueClaim으로 Pod 생성하기)
  - kubectl create -f pod-with-pvc.yaml
  - kubectl describe pod mypod
  - (포드 접속)
  - kubectl exec -it mypod -- /bin/bash
  - (마운트 및 사이즈 확인)
  - df -k
- Lab. ConfigMap
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/configmap/ 인지 확인)
  - (컨피그 맵 생성)
  - kubectl create configmap hello-cm --from-literal=language=java
  - kubectl get cm
  - kubectl get cm hello-cm -o yaml
  - (도커라이징 & ECR Push)
    - docker build -t 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1 .
    - aws ecr create-repository --repository-name user22-cm-sandbox --region ap-northeast-2
    - docker push 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1
  - (인증오류 발생 시, ECR 로그인)
    - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/
  - 클라우드에서 배포 이미지 확인
  - nano cm-deployment.yaml 파일 편집(나의 ECR Registry 정보로 수정)
  - (배포 및 서비스 생성)
    - kubectl create -f cm-deployment.yaml
    - kubectl create -f cm-service.yaml
  - (서비스 확인)
    - Service의 External-IP 접속
- Lab. Secret
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/secret/ 인지 확인)
  - (Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)
- Lab. Liveness & Readiness Probe
  - (pwd 로 현 위치가 /container-orchestration/yaml_aws/liveness/ 인지 확인)
  - (Liveness Command Probe 실습)
    - kubectl create -f exec-liveness.yaml 
    - (컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-exec
  - (Liveness HTTP Probe 실습)
    - kubectl create -f http-liveness.yaml
    - (kubectl describe로 실패 메시지 확인)
    - kubectl describe po liveness-http
  - (Liveness 와 readiness probe 동시 적용 실습)
    - kubectl create -f tcp-liveness-readiness.yaml
    - (8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)
    - kubectl describe po goproxy    
</details>

<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>

  - Lab. Ingress
    - Helm 명령으로 설치 여부 확인
    - Helm이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
      - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
      - (설치 중, sudo를 위한 비밀번호 입력) 
      - (Helm 초기화 설정)
      - (Helm 설치 관리자를 위한 시스템 사용자 생성)
      - kubectl --namespace kube-system create sa tiller 
      - kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
      - helm init --kube-context (나의 EKS 클러스터 명-Full Name) --service-account tiller
      -  (kubectl config current-context 명령으로 클러스터명 확인)
      
  - Helm으로 Ingress Controller 설치
    - helm repo add stable https://kubernetes-charts.storage.googleapis.com/
    - helm repo update
    - kubectl create namespace ingress-basic
    - helm install --name nginx-ingress stable/nginx-ingress --kube-context=My-cluster --namespace=ingress-basic
    - (설치확인)
      - kubectl get all --namespace=ingress-basic
      - (Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)
  - Ingress 대상 서비스(BLUE, GREEN) 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/blue-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - docker build -t 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest  .
      - aws ecr create-repository --repository-name user30-nginx-blue --region ap-northeast-2
      - docker push 052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest 
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-blue-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-blue-deployment.yaml  
    - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/green-svc/ 인지 확인)
      - (도커라이징 & 이미지 Push)
      - docker build -t (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest  .
      - aws ecr create-repository --repository-name nginx-green --region ap-northeast-2
      - docker push (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest
      - (배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)
      - nano nginx-green-deployment.yaml
      - (저장 ctrl + X)
      - (배포 및 서비스 생성)
      - kubectl create -f nginx-green-deployment.yaml 
    - (서비스 생성 확인)
      - kubectl get deploy,service -n ingress-basic
  - Ingress 생성
    - (pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/ 인지 확인)
    - kubectl create -f web-ingress.yaml
    - (Ingress 생성확인)
    - kubectl get ingress -n ingress-basic
  - Ingress 테스트
    - API Gateway 주소를 Local 시스템에 등록
    - Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록   
- Metric Server 설치
  - kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.6/components.yaml
  - kubectl get deployment metrics-server -n kube-system

</details>
 
<details>
<summary><b>Real MSA Application Deployment</b></summary>
   
  - 사전작업
    - aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com
    - cd  ~
    - mkdir MSA-Sample
    - cd MSA-Sample
  - 마이크로서비스 배포
    - 상품(Product) 서비스 
      "export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com
      git clone https://github.com/event-storming/reqres_products.git
      cd reqres_products
      mvn package -Dmaven.test.skip=true      
      docker build -t ${ECR}/products:latest .
      aws ecr create-repository --repository-name products --region ap-northeast-2
      docker push ${ECR}/products:latest      
      kubectl create deploy products --image=${ECR}/products:latest
      kubectl expose deploy products --type="ClusterIP" --port=8080
      cd .."
    - 주문(Order) 서비스 
      "export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com      
      git clone https://github.com/event-storming/reqres_orders.git 
            
      cd reqres_orders 
      export IMAGENAME=orders       
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 배송(Delivery) 서비스
      "git clone https://github.com/event-storming/reqres_delivery.git
      cd reqres_delivery
      export IMAGENAME=delivery
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 인증(Oauth) 서비스 
      "git clone https://github.com/event-storming/oauth.git
      cd oauth
      export IMAGENAME=oauth
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="ClusterIP" --port=8080
      
      cd .."
    - 게이트웨이(Gateway) 서비스
      "git clone https://github.com/event-storming/gateway.git
      cd gateway
      export IMAGENAME=gateway
      
      mvn package -Dmaven.test.skip=true 
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      kubectl create deploy ${IMAGENAME} --image=${ECR}/${IMAGENAME}:latest
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
    - 프론트-엔드(UI) 서비스: 빌드환경 설정(npm 설치) 
      "sudo apt-get update
      sudo apt install build-essential
      curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
      sudo apt install nodejs
      "
    - 프론트-엔드(UI) 서비스: 배포 사전 작업
      "git clone https://github.com/event-storming/ui.git
      cd ui
      export IMAGENAME=ui
      
      npm install
      npm run build
      docker build -t ${ECR}/${IMAGENAME}:latest .
      aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2
      docker push ${ECR}/${IMAGENAME}:latest
      
      _GATEWAY_IP=$(kubectl get -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" svc gateway --ignore-not-found)
      echo ${_GATEWAY_IP}"
    - 프론트-엔드(UI) 서비스: 배포 및 서비스 생성
      "cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${IMAGENAME}
        labels:
          app: ${IMAGENAME}
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ${IMAGENAME}
        template:
          metadata:
            labels:
              app: ${IMAGENAME}
          spec:
            containers:
              - name: ${IMAGENAME}
                image: ${ACR}/${IMAGENAME}:latest
                ports:
                  - containerPort: 8080
                env:
                  - name: VUE_APP_API_HOST
                    value: http://${_GATEWAY_IP}:8080
      EOF
      
      kubectl expose deploy ${IMAGENAME} --type="LoadBalancer" --port=8080
      
      cd .."
      
  - 서비스 확인
    - kubectl get svc ui
    - 브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080

</details>

<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary> 

  - 사전 작업 : AWS의 EKS Node 개수 조정(4/4) 필요 
  - Lab. Istio 설치
    - (Istio 설치)
    - curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.4.5 sh -
    - cd istio-1.4.5
    - export PATH=$PWD/bin:$PATH
    - for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done
    - kubectl apply -f install/kubernetes/istio-demo.yaml
    - (설치확인)
    - kubectl get pod -n istio-system
    
  - Lab. Istio Tutorial 셋업
    - 서비스 메시 시나리오 : 사용자 선호도에 따른 추천서비스(v1, v2)로 운영자가 설정한 가중치에 따라, 스마트 라우팅(Canary) 되는 모형을 도구를 통해 함께 모니터링
    - (Git repository에서 Tutorial 리소스 가져오기)
      - cd ~
      - mkdir git
      - cd git
      - git clone https://github.com/redhat-developer-demos/istio-tutorial
      - cd istio-tutorial
    - (네임스페이스 생성)
      - kubectl create namespace tutorial
    - (Customer 애플리케이션 배포)
      - kubectl apply -f <(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f customer/kubernetes/Service.yml -n tutorial
      - kubectl create -f customer/kubernetes/Gateway.yml -n tutorial
    - (배포 확인 및 외부접속 설정)
      - kubectl -n tutorial edit svc customer
      - (ServiceType : ClusterIP -> LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl -n tutorial get svc
    - (customer 서비스의 EXTERNAL-IP 확인, 브라우저로 EXTERNAL-IP:8080 접속)
    - (테스트 애플리케이션 배포: Rreference, Recommendation-v1)
      - kubectl apply -f <(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial
      - kubectl create -f preference/kubernetes/Service.yml -n tutorial
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial
      - kubectl create -f recommendation/kubernetes/Service.yml -n tutorial
    - 서비스 메시 모니터링 및 추적시스템의 외부접속 환경설정
      - kubectl edit svc jaeger-query -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl edit svc kiali -n istio-system
      - (ServiceType : ClusterIP를 LoadBalancer 로 변경)
        - :%s/ClusterIP/LoadBalancer/g
        - :wq!
      - kubectl get svc -n istio-system
      - 분산추적 시스템(Jaeger) 접속 : EXTERNAL-IP :16686
      - 모니터링 시스템(Kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)
  - Lab. Istio 심플 라우팅
    - (Istio의 Simple Routing 확인)
    - (recommendation 서비스 추가 배포: v2)
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
    - (Recommendation v.2 서비스 Scale Out)
    - (서비스의 v2 의 replica 를 2로 설정)
      - kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial
      - kubectl get po -n tutorial
    - 서비스 호출
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출
      - F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성
    - Routing 결과 확인
      - Kiali(Externl-IP:20001) 접속
  - Lab. Istio 스마트 라우팅
    - 정책(VirtualService, DestinationRule) 설정
      - (현, 정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)
      - (VirtualService, DestinationRule 설정, v2로 100% 라우팅)
        - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial
      - (설정정책 확인)
        - kubectl get VirtualService -n tutorial -o yaml
        - kubectl get DestinationRule -n tutorial -o yaml
      - (서비스 확인)
        - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출
        - Kiali(Externl-IP:20001), Jaeger(16686)에서 모니터링
    - 가중치 기반 스마트 라우팅
      - (recommendation 서비스 v1의 가중치를 100으로 변경)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - (서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)
      - (VirtualService 삭제 시, Round-Robin 방식으로 동작)
        - kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
      - Canary 라우팅 비율별 배포 정책 예시
        - (90 : 10)
        - kubectl create -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial
        - (75 : 25)
        - kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
        - kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial
    - Client 브라우저 유형별 스마트 라우팅
      - Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
        - kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
        - kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial
      - (Firefox 브라우저와 다른 브라우저에서 접속 확인)
      - (Browser 환경이 지원되지 않을 경우,)
        - curl -A Safari Externl-IP:8080
        - curl -A Firefox Externl-IP:8080
      - 삭제
        - kubectl delete dr recommendation -n tutorial
        - kubectl delete vs recommendation -n tutorial
  - Istio 테스트 Object 삭제
    - kubectl delete namespace tutorial
    - kubectl delete namespace istio-system

</details>


<details>
<summary><b>Back-up</b></summary> 
    
  - Container로부터 이미지 생성
    - 이미지 생성
      - docker run --name my-nginx -d -p 80:80 nginx
      - docker exec -it my-nginx /bin/bash
        - apt-get update
        - apt-get install curl
        - cd /usr/share/nginx/html
        - echo 'Hello my name is PYJ.' >> index.html
        - exit
      - docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성
      - docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인
      - docker commit -a "apex@naver.com" -m "update nginx" my-nginx my-nginx:1.0 
      - docker images
      - docker stop my-nginx
      - docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0
      - http://localhost 확인
      - docker stop my-nginx2
    - 이미지 푸시
      - docker tag my-nginx:1.0 apexacme/my-nginx:1.0
      - docker images
      - docker push apexacme/my-nginx:1.0
      - http://hub.docker.com 에서 이미지 확인
    - 도커허브 이미지로부터 컨테이너 실행
      - docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0
      
  - 샘플 자바 애플리케이션 패키징과 배포 
    - (pwd 로 현 위치가 /container-orchestration_aws/ 인지 확인)
    - git clone https://github.com/event-storming/monolith.git
    - cd monolith/
    - ls
    - (skip) mvn spring-boot:run #Maven으로 App. 실행 
    - mvn package -B -Dmaven.test.skip=true
    - (skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행
    - cat Dockerfile # 도커파일 내용 확인
    - (도커라이징)
      - docker build -t (Azure container registry명).azurecr.io/monolith:v1 .     
        - 주의1 :   명령  맨끝에 " ." 빼먹으면 안됨.   Dockerfile 의 위치인
        - 주의2 :   project id 부분을 자신의 GCP project id 로 변경!!
        - 주의3 :   현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함
      - docker images
      - (skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행
      - docker push (azure container registry명).azurecr.io/monolith:v1
    - kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1
    - kubectl get po -l app=monolith
    - kubectl expose deploy monolith --type="LoadBalancer" --port=8080
    - kubectl get svc -w
    - 자바 애플리케이션 접속
      - http://(Service_Extern-IP):8080
  - Lab. Istio Egress
    - 외부 도메인을 호출하는 v3 버전을 배포
      - kubectl apply -f <(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
    - v3에서 날짜정보가 추가로 출력됨을 확인
    - Istio 트래픽을 등록된 것만 허용하도록 변경
      - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인
    - 트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
      - kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial
      - kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial
    - 브라우저에서 Customer 서비스(Externl-IP:8080 접속)
      - 화면에 Error Log 출력 : “customer => Error: 503 - preference => Error: 500”
    - 외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
      - kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial
      - 브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력
    - (테스트 후, 설정 복구)
    - kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g' | kubectl replace -n istio-system -f -

</details>



</p>
</details>
<hr />

<br />

